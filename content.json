{"pages":[],"posts":[{"title":"知识点整理-2","text":"1. 两个有序链表合并成一个(leetcode 21) 12345678910111213141516171819202122struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {}};ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1 == NULL){ return l2; } if (l2 == NULL){ return l1; } if (l1-&gt;val &lt; l2-&gt;val){ l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } else { l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; }} 2. GET和POST的区别 GET所发送的数据是URL的一部分，POST数据不会显示在URL中。 GET和POST方法没有本质区别，只是报文格式不同，两者都使用HTTP，都是不安全的，想要安全传输需要使用HTTPS。 3. HTTPS的实现原理 HTTPS原理：在传输层（TCP）和应用层（HTTP）之间加了一层SSL/TLS。 具体加密过程：1. 服务器端发送公钥证书；2. 客户端检验证书是否有效，是，则生成一个随机密钥，并用服务端的公钥进行加密后发送；3. 服务器端用自己私钥加密，取出客户端的随机密钥，将需要发送的内容用该密钥加密并发送。 4. Linux查看最近的日志用什么指令 tail： tail -f test.log head： cat test.log | tail -n +3000 | head -n 1000 cat： cat filename tac：把cat的内容反写过来 tac filename echo： echo “the echo command test!” 5. hash冲突解决 开放地址法：再散列函数： Hi = (H(key) + di) % m, i = 1, 2, …, n 不同di值对应不同散列方法。 再哈希法：同时构造多个不同的哈希函数，某一个发生冲突时计算下一个，直到冲突不再产生。 链地址法：将所有哈希地址为i的元素构成一个单链表。 建立公共溢出区：将哈希表分为基本表和溢出表，和基本表发生冲突的元素填入溢出表。 6. 快排的时间复杂度和空间复杂度 平均情况下快速排序的时间复杂度是O(nlgn)，最坏情况是n的平方，可通过随机算法避免最坏情况，或者可先求序列的中值，然后选取中值作为主元素。 由于递归调用，快排的空间复杂度是O(lgn)。 7. 堆排序的时间复杂度和空间复杂度 第一次建堆时间复杂度：O(n)。 更改元素时建堆时间复杂度：O(nlgn)。 堆排序平均时间复杂度：O(nlgn)。 空间复杂度：O(1)。 8. B树和B+树的定义 B树中每个节点的关键字都有data域。 B+树除了叶子节点，其他节点只有索引。 9. C++ vector里size和capacity的区别 size是当前vector容器的真实占用大小。 capacity是当前允许的最大元素数。","link":"/2020/04/16/2020-04-16-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-2/"},{"title":"KMP Algorithm","text":"Background…Once upon a time, Tom asked his father to find abab inside abcaabababaa. Tom’s dad did this in a traditional way (brute force). He compared each character of the first string with each character of the second string. When he find one character not matching, for example, the third character in the second string in this case, he start again from the second character of the second string. It went on and on and on… Moving on…Unfortunately, Tom had a bad temper about waiting. He wanted to make some change. Tom noticed that, if the n-th character in the first string happened to be not match, even if he start again, he will make a compare with that character again in the future. Therefore, Tom decided not to start from the begining each time a not match is found. He talked to his dad, “when we have a not match for the n-th character, if we consider the characters before, we do have a big match, and if so, we actually can use the head of abab to try to match the tail of abab, the longest mathing substring will be the place for us to start again.” For example, for abab, there will be 3 possible heads: a, ab, aba. And there will be 3 possible tails: b, ab, bab. The longest matching is ab, so each time there’s a not mathing, we don’t need to start from begin, instead we can start from the 3-rd character to make a comparison. Coding work…Taking the above thought into real code, c++, for example: We first need a function to generate all the longest matching for each substring of the string we are trying to search. 1234567891011121314151617int * FindLongestMatching(string first){ int * tableOfFirst = new int[first.length()]; tableOfFirst[0] = -1; int i = 0; int j = -1; while (i &lt; p.length() - 1) { if (j == -1 || first[i] == first[j]) { i++； j++； tableOfFirst[i] = j; } else { j = tableOfFirst[j]; } } return tableOfFirst;} With this function, we can make a linear time matching: 123456789101112131415161718int KMP (string first, string second) { int i = 0; int j = 0; int * tableOfFirst = FindLongestMatching(first); while (i &lt; second.length() &amp;&amp; j &lt; first.length()) { if (j == -1 || second[i] == first[j]) { i++; j++; } else { j = tableOfFirst[j]; } } if (j == first.length()){ return i-j; } return -1;} Tom is happy now.","link":"/2020/04/17/2020-04-17-KMP-Algorithm/"},{"title":"知识点整理-3","text":"1. 计算机网络分层模型 7层 (osi国际标准组织定制)： 应用层：为程序提供网络服务。 表示层：数据格式化，加密、解密。 会话层：建立、维护、管理会话链接。 传输层：建立、维护、管理端到端链接。 网络层：IP寻址和路由选择。 数据链路层：控制网络层与物理层之间的通信。 物理层：比特流传输。 四层 (TCP/IP)： 应用层：ping、DNS、telnet 传输层：UDP、TCP 网络层：ICMP、IP 数据链路层：ARP、DataLink、RARP 2. HTTP请求包含哪几个部分 请求行： 请求方法：HTTP最常见的请求方法为GET和POST。 请求URL：请求对应的URL地址。 HTTP协议及版本：协议名称及版本号。 请求头： 包含多个属性，格式为“属性名：属性值”，服务器根据请求头来获取客户端的信息。 请求体： 将一个页面表单中的组件值通过param1=value &amp; param2=value2的键值对形式编码成一个格式化串，承载多个请求参数的数据。 3. TCP拥塞控制 主要为四个算法： 慢开始：在TCP链接刚建立时，一点一点地增大拥塞窗口cwnd，慢慢变为指数增长，试探网络的承受能力，直到cwnd大于等于ssthresh（slow start threshold）则进入拥塞避免。 拥塞避免：收到一个ACK，即每经过一个往返时间RTT，就把发送方的cwnd加1，使其按线性规律缓慢增长。 乘法减小【TCP Tahoe】：不论在慢开始阶段还是拥塞避免阶段，只要出现超时，即可能发生了阻塞，发生丢包，就把慢开始门限ssthresh的值减半，即设置为当前cwnd的一半，并开始执行慢开始算法。 快速重传【TCP Reno】：发生丢包时，把cwnd设置为当前的一半，ssthresh设置为缩小后的cwnd大小，进入快速恢复算法。 快速恢复【TCP Reno】：设置cwnd=cwnd+3MSS（因为收到3个重复的ACK，所以加三个MSS），重传DACKs指定的数据包，如果再收到DACKs，则cwnd增加1，若收到新的ACK，表明重传包成功，退出快速恢复，将cwnd设置为ssthresh，进入*拥塞避免**算法。 4. 死锁与死锁的处理 形成死锁的四个必要条件： 互斥：在某段时间内某资源只由一个进程占用。 持有并等待：某进程已经持有一个或多个资源，但是还需请求其他资源，而它请求的资源不能立即获得，需要等待。 不可抢占：进程已经获取的资源在使用过程中不能被其他进程抢占，只能在使用完后，由该进程自己释放。 环路等待：形成进程和请求资源之间的环路。 死锁的预防： 互斥：不易预防 占有并等待：方法一：不持有并等待，如果一个进程一次请求获取不了所有资源，那么它不可占用任何资源，即释放掉它已经占有的资源；方法二：持有不等待，保证资源充足，只要请求资源，就分配给资源。 不可抢占：如果一个进程所请求的资源被另一进程占有，使它可以抢占另一进程占有的资源。 环路等待：对资源进行排序，每个进程按照固定的顺序访问资源。 死锁的避免： 资源请求图算法：利用资源分配图，引入需求边表示进程可能在将来某个时候申请资源，只有申请边变为分配边而不会导致资源分配图形成环时，才允许申请。 银行家算法：当新进程进入系统，系统对其所需资源的最大数量进行统计，若超过当前资源综合，则该进程必须等待直到其他进程释放资源。 5. 什么是关系型数据库 关系型数据库建立在关系型数据模型的基础上，借助于集合、代数等数学概念和方法来处理数据的数据库。 6. KV存储 举例：Redis、MongoDB 不经常更新的、重要的数据一般使用关系数据库存储。 数据结构简单、有分布式数据存储的需求使用KV数据库。 7. 非递归前中后序遍历二叉树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566struct TreeNode { int val; TreeNode * left; TreeNode * right;};void PreOrder (TreeNode * root) { stack&lt;TreeNode *&gt;s; TreeNode * ptr = root; while (ptr != nullptr || !s.empty()) { if (ptr != nullptr) { cout &lt;&lt; ptr-&gt;val &lt;&lt; endl; s.push(ptr); ptr = ptr-&gt;left; } else { ptr = s.top(); s.pop(); ptr = ptr-&gt;right; } }}void InOrder (TreeNode * root) { stack&lt;TreeNode *&gt; s; TreeNode * ptr = root; while (ptr != nullptr || !s.empty()) { if (ptr != nullptr) { s.push(ptr); ptr = ptr-&gt;left; } else { ptr = s.top(); cout &lt;&lt; ptr-&gt;val &lt;&lt; endl; s.pop(); ptr = ptr-&gt;right; } }}void PostOrder (TreeNode * root) { stack&lt;TreeNode *&gt; s; TreeNode * ptr = root; TreeNode * TemNode = nullptr; while (ptr != nullptr || !s.empty()) { if (ptr != nullptr { s.push(ptr); ptr = ptr-&gt;left; } else { ptr = s.top(); if (ptr-&gt;right != nullptr &amp;&amp; ptr-&gt;right !- TemNode){ ptr = ptr-&gt;right; } else { cout &lt;&lt; ptr-&gt;val &lt;&lt; endl; s.pop(); TemNode = ptr; ptr = nullptr; } } }} 8. 如何实现一个栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class QueueStack {private: queue&lt;int&gt; first; queue&lt;int&gt; second; public: bool empty() { if (first.empty() &amp;&amp; second.empty()){ return true; } else { return false; } } int top() { if (first.empty()){ return second.front(); } else { return first.front(); } } void pop() { if (first.empty()) { second.pop(); } else { first.pop(); } } void push (int x){ if (frist.empty()){ first.push(x); while (!second.empty()) { first.push(second.front()); second.pop(); } } else { second.push(x); while(!first.empty()) { second.push(first.front()); first.pop(); } } }} 9. HTTP状态码 1xx：收到请求，需要请求者继续操作。 100：继续。 101：切换协议。 2xx：操作被成功接收并处理。 200：请求成功。 201：已创建。 202：已接受。 203：非授权信息。请求成功。 204：无内容。 205：重置内容。 206：部分内容。 3xx：重定向，需要进一步操作以完成请求。 300：多种选择。 301：永久移动。 302：临时移动。 303：查看其他地址。 304：未修改。 305：使用代理。 307：临时重定向。 4xx：客户端错误，请求包含语法错误或无法完成请求。 400：Bad Request。 401：Unauthorized。 403：服务器理解客户端的请求，但是拒绝执行。 404：无法根据请求找到资源。 405：客户端请求中的方法被禁止。 406：Not Acceptable。 407：Proxy Authentication Required。 408：Request Timeout。 409：服务器处理请求时发生了冲突。 410：客户端请求的资源已经不存在。 411：Length Required。 412：Precondition Failed。 413：Request Entity Too Large。 414：Request URI Too Large。 415：Unsupported Media Type。 416：客户端请求的范围无效。 417：Expectation Failed。 5xx：服务器错误，服务器在处理请求的过程中发生了错误。 500：服务器内部错误，无法完成请求。 501：服务器不支持请求的功能。 502：Bad Gateway。 503：Service Unavailable。 504：Gateway Timeout。 505：HTTP version not supported。","link":"/2020/04/17/2020-04-17-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-3/"},{"title":"知识点整理-1","text":"1. C++的内存管理分哪些区，分别有什么作用 C++的内存主要分为五大区：堆区、栈区、自由存储区、全局/静态存储区、常量存储区。 堆区：程序员分配释放，使用new分配内存块，使用delete归还内存空间。 栈区：编译器自动分配释放，用于存放局部变量、函数参数等。 自由存储区：程序员分配释放，使用malloc分配内存块，使用free归还内存空间。 全局区/静态区：全局变量和静态变量分配在同一块内存中。 常量存储区：存放不可修改的常量值。 2. C++源文本到可执行文件需要经历哪些阶段 预处理：将源代码和相关头文件处理成一个.i文件。 编译：将预处理的文件进行词法分析、语义分析，优化后产生相应的汇编代码。 汇编：将汇编语言代码翻译成目标机器码。 链接：把每个机器码文件按照要求连接起来，解决代码间的相互依赖问题。 3. 析构函数为什么必须是虚函数 为了保证整个派生类的对象完全被释放。 当析构函数不为虚函数时，在删除基类指针时，只会调用基类析构函数，而不调用派生类的析构函数，这样会导致基类指针指向的派生类对象析构不完全。 当析构函数为虚函数时，在删除基类指针时，会调用该指针指向派生类的析构函数，同时派生类的析构函数自动调用基类析构函数，保证对象被完全释放。 4. 虚函数和纯虚函数有什么区别 虚函数：在基类中存在定义，可以直接使用，也可以被派生类重写后使用。 纯虚函数：在基类中不存在定义，只有声明，必须在子类中定义后才能使用。 5. 虚函数的实现机制 编译器自动为存在虚函数的类生成一个虚函数表，当声明该类的对象时，放入一个隐式指针变量，指向虚函数表。 在调用方法时，系统根据不同对象的指针，寻找到对应的虚函数表，进而找到所需的函数地址进行调用。 6.野指针怎么出现的 指针变量未初始化。 指针释放后未置空。 返回指向栈内存的指针。 7. 类和结构体有什么区别 class中默认成员访问权限为private，而struct中为public。 class可以用于表示模板类型，sruct不行。 class是引用类型，struct是值类型。 class多用来存储数据量大、逻辑复杂的对象，struct多用来存储轻量级对象。 class多用于表现抽象和多级别的对象层次。 8. 什么情况会导致内存泄漏 程序循环new创建出来的对象没有及时delete掉。 delete掉一个void*类型的指针，导致没有调用到对象的析构函数。 new创建了一组对象，回收时未调用delete[]，而调用了delete，导致只有对象数组的第一个对象的析构函数得到执行并回收了内存。 9. 五种IO模型 阻塞IO：进程发起IO系统调用后，进程被阻塞，转到内核空间处理，处理完毕后返回进程。 非阻塞IO：进程发起IO系统调用后，如果内核缓冲区没有数据，返回给进程一个错误，而不会阻塞进程，如果缓冲区有数据，则将数据返回给进程。【发起IO后，内核便开始处理，一直有返回值，但是直到内核处理完才有数据。】 IO复用：多个进程的IO注册到一个复用器（select）上，select监听所有进来的IO。【同时负责很多水龙头，哪个水龙头要来水了，就打开哪一个。】 信号驱动IO：进程发起IO系统调用后，向内核注册信号处理函数，然后进程返回不阻塞，当内核数据就绪则通知进程发起IO调用读取数据。【首先用信号通知内核空间，等到数据就绪再发起IO。】 异步IO：进程发起IO系统调用后，进程返回不阻塞，等内核将IO处理完，通知进程数据结果。 10. TCP如何保证传输的可靠性 校验和：接收方和发送方均进行校验和的计算，并进行对比。 序列号：TCP传输时将每个字节的数据都进行编号。 确认应答：TCP传输过程中，每次接收方收到数据后，均对传输方进行确认应答（ACK）。 超时重传：发送方在发送完数据后进行等待，一段时间后没有收到ACK，则对刚才的数据进行重新发送。 连接管理：三次握手与四次挥手。 流量控制：在回复ACK时，接收端介绍自己接受数据的缓冲区剩余大小。 拥塞控制：慢开始、拥塞避免等操作。 11. TCP快速重传的实现 举例：发送方发出1、2、3、4、5五份数据，1送到了，则回复ACK2，但是2没送到，3送到了，于是继续回复ACK2，后面4和5都送到了，继续回复ACK2，直到发送端收到三次ACK2，则重新发送2，然后接收端收到2，因为3、4、5都已经收到，所以回复ACK6。","link":"/2020/04/15/2020-04-15-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-1/"},{"title":"知识点整理-4","text":"1. 黑盒测试和白盒测试 黑盒测试：即功能性测试 等价类划分：有效等价类即对于程序的规格来说是合理的、有意义的；无效等价类即对程序的规格来说是不合理的、每有意义的。 边界值分析：对各种边界情况设计测试用例。 因果图法：根据输入的各种组合来设计测试用例，用于检查程序输入条件的各种组合情况。 场景法：通过对正常场景和中断操作的场景进行实验来完成测试。 白盒测试：即结构测试或逻辑驱动测试 静态测试：代码检查、结构分析、文档测试等。 动态测试：功能确认、接口测试、性能分析等。 2. 单元测试、集成测试和系统 单元测试：对函数、类的某一个方法等基本单元进行正确性检验的测试。 集成测试：对组装好的模块进行功能性验证的测试。 系统测试：对继承好的软件作为计算机系统的一部分与外围设备或支持性软件一起进行的实际测试。 3. 如何设计测试用例 利用1.中方法进行分析设计，需要包含用例编号、用例标题、功能模块名称、前置条件、输入数据、操作步骤、预期结果、优先级、执行结果、编写人、执行人、其他补充。 4. 如何测试微信的点赞功能 功能测试 点赞朋友圈，是否成功。 取消点赞，是否成功。 多次点赞，有何结果。 多人点赞，以何顺序呈现。 接口测试 被点赞人能否收到消息。 点赞人能否收到后续消息。 性能测试 点赞后，结果显示时间是否符合规范。 兼容测试 在安卓、ios上点赞，结构是否有差异。 可用性测试 网络连接不稳定时，点赞的结果。","link":"/2020/04/19/2020-04-19-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-4/"},{"title":"Sorting Algorithms - Summary","text":"In this series of blogs, we will talk about different sorting algorithms. All the algorithms in the table below will be covered. Algorithm Time Complexity (Average Case) Time Complexity (Worst Case) Time Complexity (Best Case) Merg Stability Bubble Sort O(N^2) O(N^2) O(N^2) O(1) Stable Quick Sort O(NlogN) O(N^2) O(NlogN) O(logN) Not Stable Quick Sort (with Random Selection) O(NlogN) O(NlogN) O(NlogN) O(logN) Not Stable Insertion Sort O(N^2) O(N^2) O(N) O(1) Stable Selection Sort O(N^2) O(N^2) O(N^2) O(1) Not Stable Heap Sort O(NlogN) O(NlogN) O(NlogN) O(1) Not Stable Merge Sort (with double divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Merge Sort (with multi divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Counting Sort O(N+M) O(N+M) O(N+M) O(N+M) Stable Bucket Sort O(N+M) O(N^2) O(N+M) O(N+M) Stable Radix Sort O(N*M) O(N*M) O(N*M) O(N+M) Stable","link":"/2020/04/21/2020-04-21-Sorting-Algorithms---Summary/"},{"title":"Sorting Algorithms - Bubble Sort","text":"In this series of blogs, we will talk about different sorting algorithms. All the algorithms in the table below will be covered. Algorithm Time Complexity (Average Case) Time Complexity (Worst Case) Time Complexity (Best Case) Merg Stability Bubble Sort O(N^2) O(N^2) O(N^2) O(1) Stable Quick Sort O(NlogN) O(N^2) O(NlogN) O(logN) Not Stable Quick Sort (with Random Selection) O(NlogN) O(NlogN) O(NlogN) O(logN) Not Stable Insertion Sort O(N^2) O(N^2) O(N) O(1) Stable Selection Sort O(N^2) O(N^2) O(N^2) O(1) Not Stable Heap Sort O(NlogN) O(NlogN) O(NlogN) O(1) Not Stable Merge Sort (with double divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Merge Sort (with multi divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Counting Sort O(N+M) O(N+M) O(N+M) O(N+M) Stable Bucket Sort O(N+M) O(N^2) O(N+M) O(N+M) Stable Radix Sort O(N*M) O(N*M) O(N*M) O(N+M) Stable Bubble SortHow to do it…Compare the adjacent elements. If the first element is greater than the second element, swap them. Loop until reaching the last pair of elements. Repeat until all the array is sorted. How to code it…123456789void BubbleSort(int array[]) { for (int i = 0; i &lt; array.length(); i++) { for (int j = 0; i &lt; array.length() - i; j++) { if (array[j] &gt; array[j+1]) { swap(array[j], array[j+1]); } } }} How to improve it…We can make a judgement before we do the algorithm. Check whether the array is already sorted or not. 1234567891011121314void BubbleSortwithCheck(int array[]) { for (int i = 0; i &lt; array.length(); i++) { bool sorted = true; for (int j = 0; j &lt; length() - i; j++) { if (array[j] &gt; array[j+1]) { swap(array[j], array[j+1]); sorted = false; } } if (sorted) { break; } }}","link":"/2020/04/22/2020-04-22-Sorting-Algorithms---Bubble-Sort/"},{"title":"知识点整理-5","text":"1. MySQL查询10-20条的数据 1select * from table limit 10, 20 2. 查找二叉树最大深度 1234567891011121314151617181920struct TreeNode { int val; TreeNode * left; TreeNode * right; TreeNode(int x) : val(x), left(NULL), right(NULL){}};int dfs (TreeNode * root, int result) { if (!root) { return result; } int left_res = dfs(root-&gt;left, result + 1); int right_res = dfs(root-&gt;right, result + 1); return max(left_res, right_res);}int MaxDepth(TreeNode * root) { int result = 0; return dfs(root, result);} 3. 判断IP地址是否合法 12345using namespace boost::xpressive; bool CheckIP(char *ip) { cregex expression = cregex::compile(\"(25[0-4]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])[.](25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])[.](25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])[.](25[0-4]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])\"); return regex_match(ip, expression); } 4. udp如何实现可靠连接 在应用层参照TCP实现超时重传、有序接受、应答确认、滑动窗口、流量控制等功能。 现已实现的程序有RUDP、RTP、UDT。 5.MySQL 查询以135开头的手机号 1select * from test where shouji like '135%';","link":"/2020/04/20/2020-04-19-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-5/"},{"title":"EMPLACE_BACK in C++","text":"There are different type of containers in C++ STL. To add a new element into the back of a container, we normally use push_back(). In this blog, we will look into a new way of performing push back - emplace_back(). Background KnowledgeRvalue References: with aim of increasing the efficiency of C++, rvalues are included. It doesn’t need to copy the value, the rvalue reference is bound to the value itself. To claim an Rvalue: 1T &amp;&amp; T_reference = t; For emplace_back( )…How is emplace_back() defined: 12template &lt;typename T&gt; void emplace_back (T &amp;&amp; t); An example for emplace_back() from this blog: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; struct President { std::string name; std::string country; int year; President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) { std::cout &lt;&lt; \"I am being constructed.\\n\"; } President(const President&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) { std::cout &lt;&lt; \"I am being copy constructed.\\n\"; } President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) { std::cout &lt;&lt; \"I am being moved.\\n\"; } President&amp; operator=(const President&amp; other); }; int main() { std::vector&lt;President&gt; elections; std::cout &lt;&lt; \"emplace_back:\\n\"; elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994); //没有类的创建 std::vector&lt;President&gt; reElections; std::cout &lt;&lt; \"\\npush_back:\\n\"; reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936)); std::cout &lt;&lt; \"\\nContents:\\n\"; for (President const&amp; president: elections) { std::cout &lt;&lt; president.name &lt;&lt; \" was elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; } for (President const&amp; president: reElections) { std::cout &lt;&lt; president.name &lt;&lt; \" was re-elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; } } The output from the above code would be: 123456789emplace_back:I am being constructed. push_back:I am being constructed.I am being moved. Contents:Nelson Mandela was elected president of South Africa in 1994. 移动构造函数 对于拷贝构造函数、赋值构造函数必须实现指针变量的深拷贝，可能会造成高耗时。移动构造函数不会进行变量成员的深拷贝，而是交换所有权，避免拷贝时的性能损耗。 声明为： 1className(className &amp;&amp;) emplace_back() C++11新特性，声明为 12template&lt;class ... Args&gt;void emplace_back(Arg&amp;&amp; ... args); 接收一个右值引用，调用其移动构造函数，将对象移动到容器中。 对比push_back：调用对象拷贝构造函数，容器中存储拷贝后的副本。 std::move 用于将左值转化为右值引用类型。","link":"/2020/05/16/2020-05-16-emplace_back-in-C++/"},{"title":"Insurance Management System - Overview","text":"In this series of blogs, we will talk about how to build a Insurance Management web application together with database system. BackgroundTom’s dad works in an insurance company. His work is to drop down who bought what kind of insurance, on which day does the customer receives an invoice, and on which day does the customer makes a payment. Oneday, Tom’s dad talks to Tom: “Oh Tom, you see see you, one day day, only eat, do nothing, build a management system for me.” Tom becomes not happy. Rlational ModelTom’s dad talks to Tom about what information is needed. After discussion, Tom draws the following relational model: Summary of development environmentTom thinks it over and over, finally decides to apply the following development environment: Programming language: Python3.5 Framework: Django2.1.1 Database: SQLite Code editor: Pycharm Application FeaturesTo build the application, Tom mainly used the ORM model characteristic provided by Django. With ORM, so that he can treat each table as a CLASS in python and each time he insert data into that table, he simply instantiate an object, together with Object-Oriented Programming, he can make queries, add items, change information and delete object in a convenient way. The features of the application are but not restricted to: Normal UsersFor users who are new to the application, he/she can register themselves in the REGISTER page. As shown below, the REGISTER page can be access by clicking the REGISTER button on the right of system bar. If information is filled not properly, application will generate warnings to helper users. When information filled in the correct way, user will be directed to the login page with notice of successful account creation. After logging in, application will go to welcome page, where the username of user is confirmed again to make sure the user is about to purchase insurance. As long as the user has been logged in, the username and email will always be displayed on each page. After confirmation, the user will be guided to the insurance purchase page, the first insurance is Home insurance, after which user is required to enter the information about home under insurance. When Home insurance purchase is finished, user is going to the Auto insurance purchase page, after which the information about vehicle under insurance needs to be provided, and finally the driver information is also needed. Notice the side bar, there are more detailed instruction about how to buy different kinds of insurance. If the user want to check detailed information about the insurances purchased, he/she can click on the PROFILE button. In the PROFILE window, user can update email address if needed. And for each insurance listed, to check the detail information, just click on the insurance number will work. When finish browsing, user can click on LOGOUT to logout the account. Super UserFor users with administration power, they can go to 127.0.0.1:8000/admin/ to access the administrative page. After logging in, Tom can manage all stored data, including add invoice and payment information for different users. (Notice that users pay their bill in other sites, this site is just designed for users to choose insurance and look for records.) Project OutcomeIn this project, Tom designed and built a web-based database application. There are three fields Tom have outcomes: web development database development connection between web development and database development For the web development, Tom chose to use python as programming language and django as web framework. This combination guaranteed us a good view of Object Oriented Programming experience. All the users and each recorded were created as an object from CLASS Tom defined. Django is a MVT like frame, therefore, during web development, it is important to get clear of which page Tom are working on, which html Tom want to return and which template is required by django. For database, Tom used the simple but powerful SQLite to perform its duty. Together with Pycharm, Tom can clearly see the structure of our project and database, in addition to manage through admin page, Tom can also open the SQLite database with Navicat or other database management software to easily manage our SQL. The connection between database and web application is established by the ORM character of django, Tom can use OOP procedure to create and manage different records. But Tom also need to be clear about the foreign key relationship between different tables, each time Tom create or delete a record, Tom need to guarantee its foreign key (if any) is assigned. This gives us a good taste of how database is used in reality. Tom is happy now.","link":"/2020/04/28/2020-04-28-Insurance-Management-System---Overview/"},{"title":"Sorting Algorithms - Quick Sort","text":"In this series of blogs, we will talk about different sorting algorithms. All the algorithms in the table below will be covered. Algorithm Time Complexity (Average Case) Time Complexity (Worst Case) Time Complexity (Best Case) Merg Stability Bubble Sort O(N^2) O(N^2) O(N^2) O(1) Stable Quick Sort O(NlogN) O(N^2) O(NlogN) O(logN) Not Stable Quick Sort (with Random Selection) O(NlogN) O(NlogN) O(NlogN) O(logN) Not Stable Insertion Sort O(N^2) O(N^2) O(N) O(1) Stable Selection Sort O(N^2) O(N^2) O(N^2) O(1) Not Stable Heap Sort O(NlogN) O(NlogN) O(NlogN) O(1) Not Stable Merge Sort (with double divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Merge Sort (with multi divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Counting Sort O(N+M) O(N+M) O(N+M) O(N+M) Stable Bucket Sort O(N+M) O(N^2) O(N+M) O(N+M) Stable Radix Sort O(N*M) O(N*M) O(N*M) O(N+M) Stable Quick SortHow to do it…Divide and conquer. In each division, seperate the data into two parts. All elements in the first part should be all less than the elements in the second part. Loop until the array is sorted. How to code it…12345678910111213141516171819202122int partition(int array[], int left, int right) { int pivot; if (left &lt; right) { int low = left; int high = right; int key = array[left]; while (low &lt; high) { while (array[high] &gt;= ket &amp;&amp; low &lt; high) { high--; } array[low] = array[high]; while (array[low] &lt;= array[high] &amp;&amp; low &lt; high) { low++; } array[high] = array[low]; } pivot = low; array[pivot] = key; } return pivot;} 1234567void QuickSort(int array[], int left, int right) { if (left &lt; right) { int pivot = partition(array, left, right); QuickSort(array, left, pivot - 1); QuickSort(array, pivot + 1, right); }} How to improve it…12345678910void QuickSortRandom(int array[], int left, int right) { if (left &lt; right) { srand(unsigned(time(NULL))); int Tem = rand()%(right - left + 1) + left; swap(array[left], array[Tem]); int pivot = partition(array, left, right); QuickSortRandom(array, left, pivot - 1); QuickSortRandom(array, pivot + 1, right); }}","link":"/2020/04/23/2020-04-23-Sorting-Algorithms---Quick-Sort/"},{"title":"SWAP Function","text":"In this blog, we will look into several ways of implementing swap in different ways. Intermedia Variable12345int a = 1;int b = 2;int tem = a;a = b;b = temp; Addition and Subtraction12345int a = 1;int b = 2;a = a+b;b = a-b;a = a-b; Multiplication and Division12345int a = 1;int b = 2;a = a*b;b = a/b;a = a/b; XOR12345int a = 1; int b = 2;a = a^b;b = b^a; // b = b^(a^b) = b^a^b = b^b^a = 0^a = aa = a^b; // a = (a^b)^a = a^b^a = a^a^b = 0^b = b","link":"/2020/05/17/2020-05-17-SWAP-Function/"},{"title":"知识点整理-6","text":"1. Linux和端口号、进程、文件相关的命令 静态进程查看: ps 例：通过进程名查看进程号 1ps ax | fgrep [进程名] 网络查看: netstat 例：通过进程号查看进程正在监听的端口 1netstat -antp | fgrep [进程号] 例：查看端口是否正在监听 1netstat -antp | grep [端口号] 搜索指定文件内容: grep (global regular expression print) 例：搜索as在123.txt中的行号位置 1grep -n as 123.txt 2. 查找二叉树最大深度 1234567891011121314151617181920struct TreeNode { int val; TreeNode * left; TreeNode * right; TreeNode(int x) : val(x), left(NULL), right(NULL){}};int dfs (TreeNode * root, int result) { if (!root) { return result; } int left_res = dfs(root-&gt;left, result + 1); int right_res = dfs(root-&gt;right, result + 1); return max(left_res, right_res);}int MaxDepth(TreeNode * root) { int result = 0; return dfs(root, result);} 3. 判断IP地址是否合法 12345using namespace boost::xpressive; bool CheckIP(char *ip) { cregex expression = cregex::compile(\"(25[0-4]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])[.](25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])[.](25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])[.](25[0-4]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])\"); return regex_match(ip, expression); } 4. udp如何实现可靠连接 在应用层参照TCP实现超时重传、有序接受、应答确认、滑动窗口、流量控制等功能。 现已实现的程序有RUDP、RTP、UDT。 5.MySQL 查询以135开头的手机号 1select * from test where shouji like '135%';","link":"/2020/07/23/2020-07-23-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-6/"},{"title":"C++知识点总结","text":"1. 虚函数和纯虚函数 虚函数：为了动态绑定，允许被子类重新定义的成员函数， virtual returnType func(parameter); 纯虚函数：为了派生接口，virtual returnType func(parameter) = 0; 基类需要虚析构函数的原因：防止内存泄漏，假如没有虚析构函数，释放一个由基类指向派生类的对象是，不触发动态绑定，则只会调用基类析构函数，而不会调用派生类的，从而导致派生类内存空间的不到释放。 2. static和const关键字 static：存储在静态存储区，未初始化时自动初始化为0： 局部变量： 变为静态局部变量； 作用域仍为局部作用域； 离开作用域仍驻留在内存中，但不可访问； 全局变量： 变为全局静态变量； 在声明的文件之外不可见； 成员变量： 变为类的全局变量，被类的对象共享，包括派生类的对象； 必须在类外进行初始化，如int base::var = 10;，但可以用const修饰static数据成员，从而在类内初始化； 成员函数： 使得成员函数为所有对象共享，不含this指针； 可以独立访问，不需要创建实例，如base::func(3, 5); 不可直接引用类的非静态成员，但是可以引用静态成员； 不可同时用const和static修饰成员函数（const含this指针，static不含，冲突）； const： 表明变量不可修改； 限定成员函数不可修改任何数据成员； const与指针： const char *p：指向的内容不能改变； char * const p：将p声明为常指针，地址不能变，但是内容可变。 3. C++的内存分区 栈区（stack）：主要存放函数参数以及局部变量，由系统自动分配释放； 堆区（heap）：用户通过malloc/new手动申请释放，分配类似链表； 全局/静态区：存放全局变量、静态变量； 字符串常量区：字符串常量； 代码区：程序的二进制代码。 4. STL容器 底层数据结构： vector：数组； map、multimap：红黑树； unordered_map、unordered_nultimap：哈希表。 5. 内存泄漏 一般为堆内存泄漏，即程序在运行中动态申请的内存空间不使用后，未及时释放； 解决： 良好编程习惯； 重载new和delete，以链表形式自动管理分配的内存； 使用智能指针。 6. 32位、64位系统中，常用内置数据类型所占字节数 32位： char：1字节； 指针变量：4字节； short int：2字节； int：4字节； unsigned int：4字节； float：4字节； double：8字节； long：4字节； unsigned long：4字节； long long：8字节； 64位： char：1字节； 指针变量：8字节； short int：2字节； int：4字节； unsigned int：4字节； float：4字节； double：8字节； long：8字节； unsigned long：8字节； long long：8字节。 7. inline、volatile关键字 inline：解决频繁调用小函数大量消耗栈空间的问题； volatile：表明类型变量可被更改，不再优化，需要从如内存中重新读取。 8. 深拷贝与浅拷贝 拷贝函数使用场景： 一个对象以值的方式传入函数体； 一个对象以值的方式从函数返回； 一个对象需通过另一个对象进行初始化； 区别： 浅拷贝：只是增加一个指针指向已存在的内存地址； 深拷贝：增加一个指针，并且申请一个新的内存用于存放复制的对象。 9. 派生类构造/析构函数调用顺序 构造函数：先基后派； 析构函数：先派后基。 10. 数据成员初始化顺序 顺序： 基类的静态变量或全局变量； 派生类的静态变量或全局变量； 基类的成员变量； 派生类的成员变量。 11. static_cast, dynamic_cast, const_cast, reinpreter_cast区别 static_cast与dynamic_cast： 发生时间不同，一个是static编译时，一个是runtime运行时； static_cast为强制类型转换，不提供运行时的检查； dynamic_cast用于转换指针和引用，不可用于转换对象，主要用于类层次间的上行和下行转换： 上行转换：B继承自A，由B转换为A； 下行转换：B继承自A，A转换为B； 上行转换时，static_cast和dynamic_cast效果相同，下行转换时，dynamic_cast具有类型检查，更安全。 12. 定义一个空类 编译器会做什么 当用到相关函数时，编译器会去自动生成：默认构造函数、默认拷贝构造函数、默认拷贝赋值操作符、默认析构函数； 所有自动生成的函数都是inline和public的。 13. 哪些函数不能成为虚函数 构造函数：假如子类继承基类构造函数，则子类对象将使用基类构造函数构造，而基类的构造函数并不知道自类的成员，不符合语义，且，多态是通过基类指针指向子类对象实现多态的，在对象构造之前，并没有对象产生，因此无法使用多态特性，是矛盾的； 内联成员函数：内联函数在编译时展开，而虚函数是在运行时绑定的，两者相违背； 静态成员函数：在编译时确定，无法动态绑定，不支持多态。 14. 内联函数与宏定义的区别 宏定义在于处理时把所有宏名用宏体替换，内联函数在编译时进行代码插入、展开、省去调用的开销； 宏定义没有类型检查，内联函数满足函数的性质，如有返回值、参数列表等。 15. 左值引用和右值引用 左值引用要求右边的值必须能够取地址，如果不能取地址，可以使用常引用； 例：const int &amp;var = 10;等价于 const int temp = 10; const int &amp;var = temp; &lt;!--￼0--&gt; 注意：返回一个从pos开始，包含pos的n个字符，pos默认值为0，n默认值为s.size()-pos。","link":"/2020/09/01/2020-09-01-C++%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"数据库知识点总结","text":"1. 数据库范式 第一范式：列不可分； 第二范式：有主键，保证完全依赖于主键； 第三范式：无传递依赖。 2. 索引 索引：对数据库表中一个或多个列的值进行排序的数据结构，从而达到快速查询、更新数据库表数据的目的； 实现：通常使用B树或B+树，如用B树可以实现O(logn)的时间复杂度检索： B树特点（m叉树）： 树中每个节点最多有m个子节点； 所有叶子节点都在同一层； B+树特点（InnoDB的索引实现）： 所有叶子节点中包含了所有关键码信息，及指向关键码记录的指针； 叶子节点本身根据关键码大小自小而大顺序链接； 含有两个指针，一个指向根节点，一个指向关键字最小的叶子节点； B+树更适合文件和数据库索引的原因： B+树内部节点相对B树更小，磁盘读写代价更低； 每次查找都需要从根节点到叶子节点，查询效率更稳定； 索引的优点： 加快数据检索速度； 加快表与表之间的连接； 减少分组和排序语句的时间； 通过创建唯一性索引，保证数据库中每一行数据的唯一性； 设置了索引但是无法使用的情况： 模糊查询，以“%”开头的Like语句； OR语句前后没有同时使用索引； 数据类型出现隐式转化，如varchar不加单引号自动转为int； 对于多列索引，必须满足最左匹配原则： 如对于索引(a, b, c)，生效情况为a、(a, b)、(a, b, c)； 因为针对联合索引构建的B+树优先保证最左元素有序； 什么字段适合创建索引： 经常作为查询选择的字段； 经常作为表连接的字段； 经常出现在order by、group by、distinct后面的字段； 创建索引时需要注意： 非空字段：需要使用0或特殊值代替NULL，否则会使索引运算更加复杂； 索引字段越小越好：数据库存储以页为单位，一页存储的数据越多，一次IO获取数据的效率越高； 索引缺点： 时间：创建、维护索引需要耗费时间，对表中数据进行增加、删除、修改时，索引也要动态修改，降低了数据的维护速度； 空间：索引需要额外的存储空间； 索引的分类： 普通索引和唯一性索引：索引列值的唯一性； 单个索引和复合索引：索引列包含的列数； 聚簇索引和非聚簇索引： 聚簇索引：按照每张表的主键构建一个B+树，InnoDB中表数据文件本身就是按照B+树组织的索引结构； 非聚簇索引：按照value进行检索，最后获得想要数据的主键，再通过主索引进行检索； 唯一索引与主键索引： 主键索引：为主键创建的唯一索引； 唯一索引：索引列的值必须唯一，但允许有空值。 3. 数据库事务 事务的特性： 原子性（Atomicity）：事务所包含的一系列语句，要么全部成功执行，要么全部回滚； 一致性（Consistency）：事务的执行结果必须使数据库从一个一致性状态到领一个一致性状态； 隔离性（Isolation）：并发执行的并发之间不能相互影响； 持久性（Durability）：事务一旦提交，对数库中的数据改变是永久性的； 事务并发带来的问题： 脏读：一个事务读取了另一个事务未提交的数据； 不可重复读：同样条件下，两次读取结果不同，即，被读取的数据可以被其他事务修改； 幻读：同样条件下，两次读出的记录数不一样，即，被读取的数据可以被其他事务新增或删除； 隔离级别： 读未提交（Read Uncommitted）：允许一个事务读取另一个事务还没提交的数据，可能会提高性能，但是会导致脏读； 读已提交（Read Committed）：只允许读到其他事物已经提交的数据，不能避免不可重复读； 可重复读（Repeatable Read）：一个事务开启后，其他事务对于数据库的修改在本事务中不可见，直到本事务提交或回滚，但是，其他事物的删除新增可见，不能避免幻读的问题； 串行化（Serializable）：只允许事务串行执行； MySQL默认隔离级别是Repeatable Read。 4. MySQL的优化 SQL语句及索引的优化： SQL语句的优化： 通过慢查询日志，找出IO大的SQL、未命中索引的SQL，从而进行优化； 通过explain了解MySQL对于语句的处理，若扩展列extra出现Using filesort和Using temporay表示SQL需要优化； 其他tips： 优化insert语句：一次插入多值； 避免在where子句中使用!=或&lt;&gt;，以及避免在where子句中对字段进行null值判断，否则引擎会放弃使用索引而进行全表扫描； 优化嵌套查询：使用join代替子查询； 考虑用exists代替in； 索引优化： 在经常做查询选择的字段、表连接的字段、经常出现在order by/group by/distincy后的字段中建立索引； 避免索引失效； 表结构的优化： 选择合适的数据类型： 尽量选择较小的数据类型； 尽量使用简单的数据类型，int比varchar容易处理； 尽可能使用非空定义字段； 尽量避免使用text类型，非用不可需考虑分表； 表的范式优化； 垂直拆分和水平拆分： 垂直拆分：将表按照业务分类，分不到不同的数据库上，将数据压力分担到不同库上面； 水平拆分：将同一张表中的数据拆分到不同数据库中进行存储，或者把一张表拆分成多张小表； 5. drop、delete和truncate区别 delete： 用来删除表的全部或一部分数据行； 需要提交或回滚来执行或撤销删除操作； truncate： 删除表中所有数据； 不可回滚； 比delete更快，占用空间更小； drop： 删除表、所有数据行、索引等； 不可回滚； 总结：不需要一张表的时候，用drop；想删除部分数据行时，用delete；保留表结构但删除所有数据时，用truncate。 6. 悲观锁与乐观锁 悲观锁： 先获取锁在进行业务操作； 通过select … for update来实现，在当前事务结束时自动释放； MySQL中使用2.时所有扫描过的行都会上锁，需要确认使用了索引而不是全表扫描； 乐观锁： 先进行业务操作，最后更新时检查是否被更新，若未被更新，则更新成功，否则失败重试； 依靠逻辑实现； 在业务操作前获取需要锁的数据的版本号，更新时进行对比； 应用场景： 读多写少适合乐观锁； 读少写多适合悲观锁。 7. MySQL中MyISAM和InnoDB的差异 存储结构： MyISAM存储为：.frm文件存储表定义、.MYD数据文件、.MYI索引文件； InnoDB都保存在同一个数据文件中； 存储空间： MyISAM可被压缩，占据的存储空间较小； InnoDB需要更多内存和存储，会在主内存中建立专用的缓冲池，用于高速缓冲数据和索引； 事务支持： MyISAM每次查询具有原子性，执行速度比InnoDB更快，但是不支持事务； InnoDB支持事务、外键，具有事务提交、回滚等能力； 表锁差异： MyISAM只支持表级锁，CRUD时会自动给表加锁； InnoDB支持行级锁，在where主键时生效，非主键锁全表。","link":"/2020/09/01/2020-09-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"计算机网络知识点总结","text":"1. Https加密过程 客户端发起握手请求； 服务端返回已有的证书公钥（服务端通过CA认证后，拥有证书公钥和证书私钥）； 客户端验证证书是否有效； 若证书有效，则生成一个随机数； 用证书公钥加密生成的随机数； 将加密后的密钥发送给服务端； 服务端用证书私钥解密密钥； 服务端使用解密出的密钥加密要发送的内容并发送给客户端； 客户端使用秘钥解密信息。 2. 对称加密与非对称加密 对称加密：加密和解密使用同一个密钥； 非对称加密：使用公钥和私钥进行加解密。 3. CLOSE_WAIT和TIME_WAIT 在四次挥手中， CLOSE_WAIT：服务端收到FIN后，发送ACK给客户端，之后进入CLOSE_WAIT状态； TIME_WAIT：客户端收到FIN后，发送ACK给服务端，之后进入TIME_WAIT状态。 4. TCP如何保证传输可靠性 数据包校验； 重排序：TCP将失序数据进行重新排序后才交给应用层； 应答机制：回复ACK； 超时重传； 流量控制：TCP连接的每一方都有固定大小缓冲空间，通过可变大小的滑窗协议完成。 5.如何预防TCP的DDos攻击 限制同时打开SYN半链接的数目； 方法：在注册表中对TCPMaxHalfOpen相关参数进行调整； TCPMaxHalfOpen相关参数： SynAttackProtect：决定了系统受到SYN攻击时采取的保护措施，包括减少系统SYN+ACK的重试次数等； TcpMaxHalfOpen：系统允许同时打开的半链接值； TcpMaxHalfOpenRetried：决定在什么情况下系统打开SYN攻击保护； 缩短SYN半链接的Time out时间。 6. TCP如何实现拥塞控制 慢启动：以指数方式，由小到大逐渐增加拥塞窗口(cwnd)的大小，慢启动达到ssthresh阈值则进入拥塞避免； 拥塞避免：每经过一个往返时间RTT就把发送方拥塞窗口增加1，按照线性增长，发生拥塞，cwnd降为1，重新慢启动； 快重传：接收方收到失序报文后，立即发出重复确认，发送方收到三个连续重复确认则立即重传； 快恢复：发送方收到重复确认后，执行乘法减小 ，把ssthresh减半，但不执行慢开始，因为如果发生阻塞，不会收到多个重复确认，而是将cwnd设置为ssthresh大小进行拥塞避免。 7. 从输入网址到获得页面的过程 浏览器通过DNS查询对应IP地址： 浏览器搜索自身DNS缓存； 搜索操作系统DNS缓存； 向本地DNS服务器进行查询； 若不在本地域名服务器，则递归或迭代查询： 递归查询：服务器作为DNS客户向根服务器查询； 迭代查询：根服务器告知服务器需要查询的IP，服务器自己进行查询； 获取IP地址后，浏览器向服务器请求建立连接，发起三次握手； TCP连接建立后，浏览器向服务器发送HTTP请求； 浏览器对请求进行处理，并将处理结果返回给浏览器； 浏览器进行渲染，呈现页面给用户。 8. Session 与 Cookie Session： 用户访问服务器时，服务器首先检查请求中是否包含sessionId，若包含，说明session已创建，若不包含，则为用户建立一个session并分配sessionId（依赖Cookie）； 用户提交表单时，浏览器将用户的SessionId附在HTTP头信息中，服务器处理完表单将结果返回sessionId对应的用户； 若Cookie被禁用： URL重写：直接将sessionId附在URL后； 表单隐藏字段：修改表单，添加一个隐藏字段，以便提交时能够回传sessionId session共享：修改cookie的域名为父域名； 使用场景：购物车； Cookie： 若服务器需要记录用户状态，则使用response向客户端颁发一个cookie，再次请求时，浏览器将请求网址连同cookie一起提交给服务器； 会话Cookie和持久Cookie： 会话cookie：不设置过期时间，关闭浏览器窗口，cookie就消失，一般保存在内存里而不是硬盘上； 持久cookie：设置了过期时间，cookie有效指导超过了设定的过期时间，一般存储在硬盘上； 使用场景：登录网站。 9. 七层网络体系结构 物理层：实现相邻计算机节点之间比特流透明传送； 数据链路层：接手物理层的位流行驶数据，封装成帧，传送到上一层，同样，也将上一层的数据帧，拆装成位流转发到物理层； 网络层：将网络地址翻译为对应的物理地址，并通过路由算法选择最佳路径； 传输层：为不同主机上运行的进程提供逻辑通信； 区别于网络层：网络层完成主机间的逻辑通信，传输层完成应用进程间的逻辑通信； 会话层：应用程序与网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信； 表示层：对来自应用层的命令和数据进行解释； 应用层：为用户的应用进程提供网络通信服务。 10. TCP和UDP对应的常见应用层协议 TCP： FTP：文件传输协议； Telnet：用于远程登录的端口： 和ssh的区别： telnet为明文传送，ssh为加密传送； ssh使用公钥对服务器的用户进行身份验证，telnet没有使用公钥； SMTP：邮件传送协议，用于发送邮件； POP3：用于接收邮件； HTTP； UDP： DNS：域名解析服务； SNMP：网络管理协议，用于管理网络设备； TFTP：简单文件传输协议。 11. ARP 将IP地址转换为MAC地址； 网络通过帧进行传输，帧里面需要目标主机的MAC地址。 12. 常见状态码 1XX：请求已被接受，正在处理； 2XX：请求成功被处理； 3XX：重定向： ​ 301：永久性转移； ​ 302：暂时性转移； ​ 304：已缓存； 4XX：客户端请求不合法： ​ 400：请求语法有问题； ​ 403：拒绝请求； ​ 404：客户端所访问的页面不存在； 5XX：服务器不能处理合法请求： ​ 500：服务器内部错误； ​ 503：服务暂时不可用。","link":"/2020/08/31/2020-08-31-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"操作系统知识点总结","text":"1. 进程和线程 进程：系统进行资源分配的基本单位； 线程：CPU调度的基本单位： 共享进程的全部资源； 独有程序计数器、寄存器和栈。 2. 进程通信 低级通信：用信号量进行的进程间的互斥和同步； 高级通信：利用操作系统所提供的一组通信命令传送大量数据的通信方式： 共享存储器系统：例：剪贴板； 消息传递系统：例：邮槽； 管道通信系统； 通信方式： 管道： 有名管道：单向通信，有固定的读端和写端，半双工通信方式，允许无亲缘关系进程间的通信； 无名管道：数据单向流动，只能在具有亲缘关系的进程间使用； 信号量：是一个计数器，控制多进程对共享资源的访问，作为一种锁机制； 消息队列：消息的链表； 信号； 共享内存：最快的IPC，常与信号量配合，实现进程间的同步和通信； 套接字。 3. 线程通信 互斥量； 信号量； 信号。 4. 死锁 概念：在多个并发进程中，某个进程持有某种资源而又等待别的进程释放他们保持的资源，在为改变状态之前不能向前推进，从而在这一组进程中产生了死锁，多个进程被无限期地阻塞、相互等待的状态； 必要条件： 互斥：一个资源每次只能被一个进程使用； 不可抢占：进程已获得的资源，在未使用完之前，不能前行剥夺； 占有并等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放； 环形等待：若干进程之间形成一种首尾相接的循环等待资源关系； 死锁的解除与预防： 破坏互斥： 允许系统资源都能共享； 缺点：有些资源不能同时访问，如打印机，且在某些场合应保护互斥性； 破坏占有并等待： 预先静态分配，在进程运行前一次申请完它所需要的全部资源，在它的资源未满足前，不投入运行，一旦投入运行资源全部归他所有； 缺点：系统资源浪费，个别资源长期被占用，导致一些进程不能运行； 破坏不可抢占： 当一个进程保持了某些资源，请求新资源而不能被满足时，必须释放所保持的资源，以后重新申请； 缺点：实现复杂，释放资源可能会造成前一阶段工作失效，常用于易于保存和回恢复的资源； 破坏循环等待： 给系统资源编号，规定进程必须按照编号递增的顺序请求资源； 缺点：实现复杂，编号不一定与实际使用顺序相同； 避免死锁的方式： 判断系统状态：在分配前，先计算分配的安全性； 银行家算法： 申请的贷款额度不能超过银行西安有资金总额； 分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额； 暂时不能满足客户申请的资金额度时，在有限时间内给予贷款； 客户要在规定时间内还款。 5. 分段与分页内存管理的区别 分段：符合用户视角，将地址空间分为若干段：代码段、数据段、堆、栈； 分页：方便系统管理，将逻辑地址划分为固定大小的页，物理内存划分为同样大小的帧，方便程序加载。 6. 虚拟内存 让每个进程拥有独立的地址空间，且这些空间被分为大小相等的页，被映射到物理内存中，对进程而言，逻辑上有很大的内存空间，但其中一部分对应于物理内存，还有一些在硬盘上； 页面置换算法：FIFO、LRU、LFU、OPT； 优点： 物理内存可为多个进程共享； 通过共享页允许进程间共享内存 虚拟内存大小： 对于32位：0-2^32 ~= 0-4G； 对于64位：0-2^64；","link":"/2020/08/31/2020-08-31-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"LeetCode题目总结-Two Pointer+Linked List","text":"题目3:无重复字符的最长子串 描述： 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 思路一： 突破点：滑动窗口。 步骤： 设立指针a和指针b； b指针向右伸缩，对于每个A[b]判断是否之前出现过； 若出现，则a指向出现过的未知的下一位置，更新右指针和最大长度。 代码： 1234567891011121314151617181920212223class Solution {public: int lengthOfLongestSubstring(string s) { //s[start,end) 前面包含 后面不包含 int start(0), end(0), length(0), result(0); int stringSize = int(s.size()); while (end &lt; stringSize) { char tmpChar = s[end]; for (int index = start; index &lt; end; index++) { if (tmpChar == s[index]) { start = index + 1; length = end - start; break; } } end++; length++; result = max(result, length); } return result; }}; 思路二： 突破点：hashMap。 步骤： 与思路一类似； 在判断是否出现过时，使用hashmap优化时间。 b指针向右伸缩，对于每个A[b]判断是否之前出现过； 若出现，则a指向出现过的未知的下一位置，更新右指针和最大长度。 代码： 12345678910111213141516171819202122232425class Solution {public: int lengthOfLongestSubstring(string s) { //s[start,end) 前面包含 后面不包含 int start(0), end(0), length(0), result(0); int sSize = int(s.size()); unordered_map&lt;char, int&gt; hash; while (end &lt; sSize) { char tmpChar = s[end]; //仅当s[start,end) 中存在s[end]时更新start if (hash.find(tmpChar) != hash.end() &amp;&amp; hash[tmpChar] &gt;= start) { start = hash[tmpChar] + 1; length = end - start; } hash[tmpChar] = end; end++; length++; result = max(result, length); } return result; }}; 题目75:颜色分类 描述： 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2]进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 思路： 突破点：三指针。 步骤： 定义三个指针p0、p2、curr来追踪0、2的边界以及当前考虑的元素； 初始化p0 = 0，p2 = n-1； 当curr&lt;=p2时，如果nums[curr] = 0，则交换curr和p0所指元素，并将curr和p0右移； 如果nums[curr] = 2，则交换curr和p2所指元素，并将p2左移，注意此时为了将判断移过来的元素类型而不右移curr； 如果nums[curr] = 1，则curr右移。 代码： 1234567891011121314151617181920212223class Solution { public: /* 荷兰三色旗问题解 */ void sortColors(vector&lt;int&gt;&amp; nums) { // 对于所有 idx &lt; p0 : nums[idx &lt; p0] = 0 // curr 是当前考虑元素的下标 int p0 = 0, curr = 0; // 对于所有 idx &gt; p2 : nums[idx &gt; p2] = 2 int p2 = nums.size() - 1; while (curr &lt;= p2) { if (nums[curr] == 0) { swap(nums[curr++], nums[p0++]); } else if (nums[curr] == 2) { swap(nums[curr], nums[p2--]); } else curr++; } }}; 题目88:合并两个有序数组 描述： 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 思路: 突破点：归并排序思想。 步骤： 获取nums1数组的尾部指针； 从两数组尾部开始，交换较大值和nums1尾部位置。 代码： 1234567891011void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int i = nums1.size() - 1; m--; n--; while (n &gt;= 0) { while (m &gt;= 0 &amp;&amp; nums1[m] &gt; nums2[n]) { swap(nums1[i--], nums1[m--]); } swap(nums1[i--], nums2[n--]); }} 题目125:验证回文串 描述：给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 思路： 突破点：首尾指针比较。 步骤： 一个指针指向头部，一个指针指向尾部； 分别从首尾开始比较，数字全部转化为小写比较； 如果有不同，则返回false。 代码： 1234567891011class Solution {public: bool isPalindrome(string s) { for (int i = 0, j = s.length() - 1; i &lt; j; i ++, j --) { while(i &lt; j &amp;&amp; !isalnum(s[i])) i ++; while(i &lt; j &amp;&amp; !isalnum(s[j])) j --; if(tolower(s[i]) != tolower(s[j])) return false; } return true; }}; 题目76:最小覆盖子串 描述： 给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。 示例： 输入：S = “ADOBECODEBANC”, T = “ABC”输出：”BANC” 提示： 如果 S 中不存这样的子串，则返回空字符串 “”。如果 S 中存在这样的子串，我们保证它是唯一的答案。 思路： 突破点：滑动窗口。 步骤： 声明两个指针left和right，right用于延伸窗口，left用于收缩窗口； 首先移动right使得窗口内包含t所有字符； 然后收缩left且保证收缩过程中t仍在窗口内； 使用哈希表动态维护窗口中字符数以及t中字符数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: unordered_map &lt;char, int&gt; ori, cnt; // 步骤4 bool check() { for (const auto &amp;p: ori) { if (cnt[p.first] &lt; p.second) { return false; } } return true; } // 滑窗 string minWindow(string s, string t) { for (const auto &amp;c: t) { ++ori[c]; } // 步骤1 int l = 0, r = -1; int len = INT_MAX, ansL = -1, ansR = -1; // 步骤2 while (r &lt; int(s.size())) { if (ori.find(s[++r]) != ori.end()) { ++cnt[s[r]]; } // 步骤3 while (check() &amp;&amp; l &lt;= r) { if (r - l + 1 &lt; len) { len = r - l + 1; ansL = l; } if (ori.find(s[l]) != ori.end()) { --cnt[s[l]]; } ++l; } } return ansL == -1 ? string() : s.substr(ansL, len); }}; 题目206:反转链表 描述： 反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 思路一： 突破点：双指针。 步骤： 定义一前一后两个指针pre和cur； 每次让pre的next指向cur，实现局部反转； 局部反转后，两个指针同时前移一位，直到pre到达链表结尾。 代码： 12345678910111213class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* cur = nullptr, *pre = head; while (nullptr != pre) { ListNode* t = pre-&gt;next; pre-&gt;next = cur; cur = pre; pre = t; } return cur; }}; 思路二： 突破点：递归。 步骤： 一直递归到链表最后一个节点； 每次返回时，让当前节点的下一节点的next指针指向当前节点； 让当前节点的next指针指向nullptr； 递归函数全部出栈后，反转完成。 代码： 123456789101112class Solution {public: ListNode* reverseList(ListNode* head) { if (nullptr == head || nullptr == head-&gt;next) { return head; } ListNode* ret = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return ret; }}; 题目21:合并两个有序链表 描述： 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路： 突破点：递归。 步骤： 递归时，首先比较两个输入头节点的大小； 若list1小于list2的头节点，则尾部添加list1后继续递归； 若list1大于list2的头节点，则尾部添加list2后继续递归。 代码： 12345678910111213141516class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if (nullptr == l1) { return l2; } else if (nullptr == l2) { return l1; } else if (l1-&gt;val &lt; l2-&gt;val) { l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } else { l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; } }}; 题目23:合并K个升序链表 描述： 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6示例 2： 输入：lists = []输出：[]示例 3： 输入：lists = [[]]输出：[] 提示： k == lists.length0 &lt;= k &lt;= 10^40 &lt;= lists[i].length &lt;= 500-10^4 &lt;= lists[i][j] &lt;= 10^4lists[i] 按 升序 排列lists[i].length 的总和不超过 10^4 思路一： 突破点：分治合并。 步骤： 将k个链表配对，并两两合并； 重复1.中过程，直到得到最终链表。 代码： 123456789101112131415161718192021222324252627282930class Solution {public: ListNode* mergeTwoLists(ListNode *a, ListNode *b) { if ((!a) || (!b)) return a ? a : b; ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b; while (aPtr &amp;&amp; bPtr) { if (aPtr-&gt;val &lt; bPtr-&gt;val) { tail-&gt;next = aPtr; aPtr = aPtr-&gt;next; } else { tail-&gt;next = bPtr; bPtr = bPtr-&gt;next; } tail = tail-&gt;next; } tail-&gt;next = (aPtr ? aPtr : bPtr); return head.next; } ListNode* merge(vector &lt;ListNode*&gt; &amp;lists, int l, int r) { if (l == r) return lists[l]; if (l &gt; r) return nullptr; int mid = (l + r) &gt;&gt; 1; return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r)); } ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { return merge(lists, 0, lists.size() - 1); }}; 思路二： 突破点：优先队列。 步骤： 维护当前每个链表没有别合并的元素最前面的一个； 每次在1.中选取val值最小的元素合并到result中； 使用优先队列进行优化。 代码： 1234567891011121314151617181920212223242526class Solution {public: struct Status { int val; ListNode *ptr; bool operator &lt; (const Status &amp;rhs) const { return val &gt; rhs.val; } }; priority_queue &lt;Status&gt; q; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { for (auto node: lists) { if (node) q.push({node-&gt;val, node}); } ListNode head, *tail = &amp;head; while (!q.empty()) { auto f = q.top(); q.pop(); tail-&gt;next = f.ptr; tail = tail-&gt;next; if (f.ptr-&gt;next) q.push({f.ptr-&gt;next-&gt;val, f.ptr-&gt;next}); } return head.next; }};","link":"/2020/09/06/2020-09-06-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Two-Pointer+Linked-List/"},{"title":"LeetCode题目总结-Array","text":"题目31:下一个排列 描述： 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路： 突破点：下一个更大排列的特性是什么。 步骤（以[5,6,11,9,7,5,3,1]举例）： 从尾部查找，直到找到当前元素大于前一元素，记录所在位置； 例：[5,6,11,9,7,5,3,1]，找到11大于6，记录位置2； 从1.中的位置到数组尾部的子序列中，找到一个比前一位置的大且相差最小的数； 例：[5,6,11,9,7,5,3,1]，在[11,9,7,5,3,1]找到7，7是比6大且最接近6的，从尾部开始遍历，遍历到大于6的索引即可； 交换2.中找到的数以及1.中确定的前一位置的数； 例：[5,6,11,9,7,5,3,1]，交换后变为[5,7,11,9,6,5,3,1]； 将该位置到数组尾部的子序列进行升序排列，因为已经为降序（1.中确定的位置为首次部位降序的位置），所以首尾两两交换即可； 例：[5,7,11,9,6,5,3,1],交换后为[5,7,1,3,5,6,9,11]； 另外，对于最大的排列，从小到大排列即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 步骤2函数int findMin(vector&lt;int&gt; nums, int i) { int pivotEle = nums[i-1]; for (i = nums.size() - 1; i &gt; -1; i--) { if (nums[i] &gt; pivotEle) { break; } } return i;}// 步骤4函数，也可以用 reverse(nums.begin()+i, nums.end());实现void swap(vector&lt;int&gt; &amp;nums, int i) { int end = nums.size() - 1; while (i &lt; end) { int temp = nums[i]; nums[i] = nums[end]; nums[end] = temp; i++; end--; }}class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int i; for(i = nums.size()-1; i&gt;0; i--){ // 步骤1 if(nums[i] &gt; nums[i-1]) { int minIndex = findMin(nums, i); //步骤3 int minEle = nums[minIndex]; nums[minIndex] = nums[i-1]; nums[i-1] = minEle; swap(nums, i); break; } } if(0 == i) { sort(nums.begin(), nums.end()); } }}; 题目46:全排列 描述： 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 思路一： 突破点：回溯法。 步骤（以[2, 5, 8, 9, 10]为例）： 定义backtrack(first, ouput)函数，表示从左到右填到第first个位置，当前排列为ouput，进行递归； 如果n==first，证明已经填完，结束递归； 如果n&gt;first，可通过标记数组标记已经填过的数，填入未标记的数字后，调用backtrack(first+1, output)； 优化空间：将标记数组划分为左右两部分，左边已填过，右边未填过，动态维护。 例：[2, 5, 8, 9, 10]中已经填了[8, 9]，此时数组为[8, 9 | 2, 5, 10]，要填10，则交换2和10，数组变为[8, 9, 10 | 2, 5]。 代码： 123456789101112131415161718192021222324class Solution {public: void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len){ if (first == len) { // 关于emplace_back有专门的文章 res.emplace_back(output); return; } for (int i = first; i &lt; len; ++i) { // 动态维护数组 swap(output[i], output[first]); // 继续递归填下一个数 backtrack(res, output, first + 1, len); // 撤销操作 swap(output[i], output[first]); } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt; &gt; res; backtrack(res, nums, 0, (int)nums.size()); return res; }}; 思路二：（注意输出顺序与题目要求不符） 突破点：递归。 步骤（以[1, 2, 3]为例）： 数组中每一个元素与最后一个元素互换； 例：[1, 2, 3]得到：[3, 2, 1]、[1, 3, 2]、[1, 2, 3]； 将最后一个元素进行保存，考虑剩余元素，对剩余元素进行递归全排列求解； 例：对1.中[3, 2, 1]，递归求解[3, 2]得到[[3, 2], [2, 3]]； 将2.中保存的最后元素加入子序列，得到结果； 例：对2.中，得到[[3, 2, 1], [2, 3, 1]]； 继续循环完成剩余情况。 例：[1, 2, 3]剩余[1, 3, 2]和[1, 2, 3]。 代码： 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt; &gt; ans; if(1 == nums.size()) { ans.push_back(nums); return ans; } else { vector&lt;vector&lt;int&gt; &gt; tempAns; vector&lt;int&gt; ncp = nums; //步骤4 for(int i = 0; i &lt; nums.size(); i++) { //步骤1 int temp = nums[i]; nums[i] = nums[nums.size()-1]; nums[nums.size()-1] = temp; //步骤2 int end = nums[nums.size()-1]; nums.pop_back(); tempAns=permute(nums); //步骤3 for (auto j : tempAns) { j.push_back(end); ans.push_back(j); } nums = ncp; } return ans; } } }; 题目79:单词搜索 描述： 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]给定 word = &quot;ABCCED&quot;, 返回 true给定 word = &quot;SEE&quot;, 返回 true给定 word = &quot;ABCB&quot;, 返回 false 提示： board 和 word 中只包含大写和小写英文字母。 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 1 &lt;= word.length &lt;= 10^3 思路： 突破点：深度优先搜索。 步骤（以ABCCEE为例）： 采用暴力搜索找到第一个字符； 例：ABCCEE中的A； 按照深度优先搜索寻找是否有匹配字符串，找到返回true，没有则寻找下一个第一字符； 例：如果没找到，继续寻找下一个A； 为了避免重复，将搜索过的字符置为0。 代码： 12345678910111213141516171819202122232425262728293031class Solution {public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { if(0 == board.size()) { return false; } for (int i= 0; i &lt; board.size(); i++) { for(int j = 0; j &lt; board[0].size(); j++) { if (dfs(board, word, i, j, 0)){ return true; } } } return false; } bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word, int i,int j,int length){ if (i &gt;= board.size() || j &gt;= board[0].size() || i &lt; 0 || j &lt; 0 || length &gt;= word.size() || word[length] != board[i][j]) { return false; } if(length == word.size()-1 &amp;&amp; word[length] == board[i][j]) { return true; } char temp = board[i][j]; board[i][j] = '0'; bool flag = dfs(board, word, i, j+1, length+1) || dfs(board, word, i, j-1, length+1) || dfs(board, word, i+1, j, length+1) || dfs(board, word, i-1, j, length+1); // 标记过的点恢复原状，以便进行下一次搜索 board[i][j] = temp; return flag; }}; 题目212:单词搜索II 描述： 给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。 示例: 输入:words = [“oath”,”pea”,”eat”,”rain”] and board =[ [‘o’,’a’,’a’,’n’], [‘e’,’t’,’a’,’e’], [‘i’,’h’,’k’,’r’], [‘i’,’f’,’l’,’v’]] 输出: [“eat”,”oath”]说明:你可以假设所有输入都由小写字母 a-z 组成。 提示: 你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。 思路： 突破点：前缀树。 步骤： 对于board使用DFS； 使用前缀树，在递归遍历前缀树时，在当前字符不同时分开遍历。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct Node { bool word; string str; unordered_map&lt;char, Node*&gt; words;};class Trie {public: Trie() { root = new Node(); } void insert(string word) { Node* p = root; for (char c: word) { if (p-&gt;words.find(c) == p-&gt;words.end()) { Node* t = new Node(); p-&gt;words[c] = t; } p = p-&gt;words[c]; } // node对应的word，为了之后根据node来找到结果 p-&gt;str = word; p-&gt;word = true; } void search(vector&lt;string&gt;&amp; res, vector&lt;vector&lt;char&gt;&gt;&amp; board) { for (int i = 0; i &lt; board.size(); i++) { for (int j = 0; j &lt; board[i].size(); j++) { help(res, board, root, i, j); } } } void help(vector&lt;string&gt;&amp;res, vector&lt;vector&lt;char&gt;&gt;&amp; board, Node* p, int x, int y) { if (p-&gt;word) { // 其他方向就不会再把答案放进去了 p-&gt;word = false; res.push_back(p-&gt;str); return; } if (x &lt; 0 || x == board.size() || y &lt; 0 || y == board[x].size()) return; if (p-&gt;words.find(board[x][y]) == p-&gt;words.end()) return; // 此时的p是其他字符了 p = p-&gt;words[board[x][y]]; char cur = board[x][y]; board[x][y] = '0'; help(res, board, p, x+1, y); help(res, board, p, x-1, y); help(res, board, p, x, y+1); help(res, board, p, x, y-1); board[x][y] = cur; } private: Node* root;};class Solution {public: vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) { Trie trie; vector&lt;string&gt; res; for (string&amp; w: words) { trie.insert(w); } trie.search(res, board); return res; }}; 题目84:柱状图中最大的矩形 描述： 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 例，给定的高度为 [2,1,5,6,2,3]。 所能勾勒出的最大矩形面积为 10 个单位。 思路： 突破点：单调栈。 步骤： 对于每一个高度，利用单调栈获取向左和向右的边界； 对每个高度求一次面积； 遍历所有高度，求出最大面积。 代码： 1234567891011121314151617int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int ans = 0; vector&lt;int&gt; monoStack; heights.insert(heights.begin(), 0); heights.push_back(0); for (int i = 0; i &lt; heights.size(); i++) { while (!monoStack.empty() &amp;&amp; heights[monoStack.back()] &gt; heights[i]) { int cur = monoStack.back(); monoStack.pop_back(); int left = monoStack.back() + 1; int right = i - 1; ans = max(ans, (right - left + 1) * heights[cur]); } monoStack.push_back(i); } return ans;} 题目85:最大矩形 描述： 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例: 输入:[ [“1”,”0”,”1”,”0”,”0”], [“1”,”0”,”1”,”1”,”1”], [“1”,”1”,”1”,”1”,”1”], [“1”,”0”,”0”,”1”,”0”]]输出: 6 思路： 突破点：动态规划。 步骤： heights[i][j]代表[i, j]的高度； dp[i][j][p]代表以[i, j]为右下角，高度为k可以组成的面积。 代码： 1234567891011121314151617181920212223242526class Solution {public: int maximalRectangle(vector&lt;vector&lt;char&gt; &gt;&amp; matrix) { int n = matrix.size(); int m = 0; if (n &gt; 0) { m = matrix[0].size(); } vector&lt;vector&lt;int&gt; &gt; heights(n+1, vector&lt;int&gt;(m+1, 0)); vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; dp(n+1, vector&lt;vector&lt;int&gt; &gt;(m+1, vector&lt;int&gt;(n+1, 0))); int ans = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if ('0' == matrix[i-1][j-1]) { continue; } heights[i][j] = heights[i-1][j] + 1; for (int k = 1; k &lt;= heights[i][j]; k++) { dp[i][j][k] = dp[i][j-1][k] + k; ans = max(ans, dp[i][j][k]); } } } return ans; }}; 题目153:寻找旋转排序数组中的最小值 描述： 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2]输出: 1 思路： 突破点：二分查找。 代码： 12345678910111213141516class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int left = 0; int right = nums.size() - 1; while (left &lt; right) { int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) { left = mid + 1; } else { right = mid; } } return nums[left]; }}; 题目154:寻找旋转排序数组中的最小值 II 描述： 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 注意数组中可能存在重复的元素。 示例 1： 输入: [1,3,5]输出: 1示例 2： 输入: [2,2,2,0,1]输出: 0说明： 这道题是 寻找旋转排序数组中的最小值 的延伸题目。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？ 思路： 突破点：二分查找。 代码： 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { if(nums.empty()) return -1; if(1 == nums.size()) return nums[0]; int p1 = 0, p2 = nums.size() - 1; // 假如旋转了数组的前面0个元素（也就是没有旋转），我们直接返回numbers[p1] int mid = p1; while(nums[p1] &gt;= nums[p2]) { if(1 == p2 - p1) { // 循环终止条件：当p2-p1=1时，p2所指元素为最小值 mid = p2; break; } // 二分法找中点 mid = (p2 + p1) / 2; // 特殊情况：p1、mid、p2三处的元素的值一样，无法判断最小值在mid前面还是后面，就只能顺序查找了 if(nums[p1] == nums[p2] &amp;&amp; nums[p1] == nums[mid]) return findMin(nums, p1, p2); // 缩小范围，mid处值大于等于p1处值的话，说明最小值在mid处或mid后面，故将p1挪到mid处 if(nums[mid] &gt;= nums[p1]) p1 = mid; // 缩小范围，mid处值小于p1处值的话，说明最小值在mid处或mid前面，故将p2挪到mid处 else p2 = mid; } return nums[mid]; } // 顺序查找 int findMin(vector&lt;int&gt;&amp; nums, int p1, int p2) { int res = nums[p1]; for(int i=p1+1; i&lt;=p2; ++i) { if(nums[i] &lt; res) return nums[i]; } return res; }};","link":"/2020/09/06/2020-09-06-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Array/"},{"title":"LeetCode题目总结-DFS+BFS","text":"题目116:填充每个节点的下一个右侧节点指针 描述： 给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node { int val; Node *left; Node *right; Node *next;} 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例： 输入：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1} 输出：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1} 提示： 你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 思路： 突破点：广度优先搜索。 步骤： 使用队列进行广度优先遍历； 在接点出队列后，next指向队列首个元素，广度遍历完直接return。 代码： 123456789101112131415161718192021222324252627282930313233class Solution {public: Node* connect(Node* root) { if(!root) return root; queue&lt;Node*&gt; work; work.push(root); work.push(nullptr); Node* cur = nullptr; while(1) { // 如果队列首部是结点 if(work.front()) { cur = work.front(); work.pop(); // 如果是非叶子结点 if(cur-&gt;left) { work.push(cur-&gt;left); work.push(cur-&gt;right); } cur-&gt;next = work.front(); } // 如果只剩下一个nullptr结点 else if (1 == work.size()) { return root; } // 如果遇到nullptr结点，这是一层的分割点 else { work.pop(); work.push(nullptr); } } return root; }}; 题目117:填充每个节点的下一个右侧节点指针 II 描述： 给定一个二叉树 struct Node { int val; Node *left; Node *right; Node *next;}填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 进阶： 你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例： 输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#] 提示： 树中的节点数小于 6000-100 &lt;= node.val &lt;= 100 思路： 突破点：层次遍历。 步骤： 使用队列层次遍历； 每循环一层将这一层清空，录入孩子节点。 代码： 123456789101112131415161718192021222324252627class Solution {public: Node* connect(Node* root) { if(!root) { return root; } queue&lt;Node*&gt; q{{root}}; while(!q.empty()) { int n = q.size(); for(int i = 0; i &lt; n; i++){ Node* t = q.front(); q.pop(); if(n-1 != i){ Node* tNext = q.front(); t-&gt;next = tNext; } if(t-&gt;left) { q.push(t-&gt;left); } if(t-&gt;right) { q.push(t-&gt;right); } } } return root; }}; 题目200:岛屿数量 描述： 给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1: 输入:[[‘1’,’1’,’1’,’1’,’0’],[‘1’,’1’,’0’,’1’,’0’],[‘1’,’1’,’0’,’0’,’0’],[‘0’,’0’,’0’,’0’,’0’]]输出: 1示例 2: 输入:[[‘1’,’1’,’0’,’0’,’0’],[‘1’,’1’,’0’,’0’,’0’],[‘0’,’0’,’1’,’0’,’0’],[‘0’,’0’,’0’,’1’,’1’]]输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 思路一： 突破点：深度优先搜索。 步骤： 将二维网格视为无向图，相邻1之间有边相连； 搜索到1，则标记为0； 最终深度优先搜索次数即为岛屿数量。 代码： 12345678910111213141516171819202122232425262728293031class Solution {private: void dfs(vector&lt;vector&lt;char&gt; &gt;&amp; grid, int r, int c) { int nr = grid.size(); int nc = grid[0].size(); grid[r][c] = '0'; if ('1' == r - 1 &gt;= 0 &amp;&amp; grid[r-1][c]) dfs(grid, r - 1, c); if ('1' == r + 1 &lt; nr &amp;&amp; grid[r+1][c]) dfs(grid, r + 1, c); if ('1' == c - 1 &gt;= 0 &amp;&amp; grid[r][c-1]) dfs(grid, r, c - 1); if ('1' == c + 1 &lt; nc &amp;&amp; grid[r][c+1]) dfs(grid, r, c + 1); }public: int numIslands(vector&lt;vector&lt;char&gt; &gt;&amp; grid) { int nr = grid.size(); if (!nr) return 0; int nc = grid[0].size(); int num_islands = 0; for (int r = 0; r &lt; nr; ++r) { for (int c = 0; c &lt; nc; ++c) { if ('1' == grid[r][c]) { ++num_islands; dfs(grid, r, c); } } } return num_islands; }}; 思路二： 突破点：广度优先搜索。 步骤： 将二维网格视为无向图，相邻1之间有边相连； 搜索到1，则加入队列，并修改标记为0； 最终广度优先搜索次数即为岛屿数量。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int numIslands(vector&lt;vector&lt;char&gt; &gt;&amp; grid) { int nr = grid.size(); if (!nr) return 0; int nc = grid[0].size(); int num_islands = 0; for (int r = 0; r &lt; nr; ++r) { for (int c = 0; c &lt; nc; ++c) { if (grid[r][c] == '1') { ++num_islands; grid[r][c] = '0'; queue&lt;pair&lt;int, int&gt; &gt; neighbors; neighbors.push({r, c}); while (!neighbors.front()) { auto rc = neighbors.front(); neighbors.pop(); int row = rc.first, col = rc.second; if (0 &lt;= row - 1 &amp;&amp; '1' == grid[row-1][col]) { neighbors.push({row-1, col}); grid[row-1][col] = '0'; } if (row + 1 &lt; nr &amp;&amp; grid[row+1][col] == '1') { neighbors.push({row+1, col}); grid[row+1][col] = '0'; } if (col - 1 &gt;= 0 &amp;&amp; grid[row][col-1] == '1') { neighbors.push({row, col-1}); grid[row][col-1] = '0'; } if (col + 1 &lt; nc &amp;&amp; grid[row][col+1] == '1') { neighbors.push({row, col+1}); grid[row][col+1] = '0'; } } } } } return num_islands; }}; 题目207:课程表 描述： 你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例 1: 输入: 2, [[1,0]]输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。示例 2: 输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示： 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。1 &lt;= numCourses &lt;= 10^5 思路一： 突破点：深度优先搜索。 步骤： 题目即寻找有向图中是否成环； 通过深度优先搜索，寻找拓扑排序； 如果存在，说明无环，如果不存在，说明有环。 代码： 12345678910111213141516171819202122232425262728293031323334353637class Solution {private: vector&lt;vector&lt;int&gt; &gt; edges; vector&lt;int&gt; visited; bool valid = true;public: void dfs(int u) { visited[u] = 1; for (int v: edges[u]) { if (0 == visited[v]) { dfs(v); if (!valid) { return; } } else if (1 == visited[v]) { valid = false; return; } } visited[u] = 2; } bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) { edges.resize(numCourses); visited.resize(numCourses); for (const auto&amp; info: prerequisites) { edges[info[1]].push_back(info[0]); } for (int i = 0; i &lt; numCourses &amp;&amp; valid; ++i) { if (!visited[i]) { dfs(i); } } return valid; }}; 思路二： 突破点：广度优先搜索。 步骤： 题目即寻找有向图中是否成环； 通过广度优先搜索，寻找拓扑排序； 寻找所有入度为0的点放入队列； 每一步广度优先搜索时，取出队首节点，加入答案中； 移除该点的所有出边； 如果有某个相邻节点入度变为0，则将该节点加入答案； 结束后，如果答案包含n各节点，则找到一种拓扑排序； 否则，说明存在环。 代码： 123456789101112131415161718192021222324252627282930313233343536class Solution {private: vector&lt;vector&lt;int&gt; &gt; edges; vector&lt;int&gt; indeg;public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) { edges.resize(numCourses); indeg.resize(numCourses); for (const auto&amp; info: prerequisites) { edges[info[1]].push_back(info[0]); ++indeg[info[0]]; } queue&lt;int&gt; q; for (int i = 0; i &lt; numCourses; ++i) { if (0 == indeg[i]) { q.push(i); } } int visited = 0; while (!q.empty()) { ++visited; int u = q.front(); q.pop(); for (int v: edges[u]) { --indeg[v]; if (0 == indeg[v]) { q.push(v); } } } return visited == numCourses; }}; 题目210:课程表 II 描述： 现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例 1: 输入: 2, [[1,0]]输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。示例 2: 输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。说明: 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。拓扑排序也可以通过 BFS 完成。 思路： 突破点：深度优先搜索。 步骤： 思考过程与题目207类似； 当我们标记当前节点u为”搜索中“后，遍历每个相邻节点v； 如果为未搜索，则开始搜索v，搜索完成后回溯到u； 如果为搜索中，则找到一个环，返回false； 如果为已完成，说明v已经在栈中，不进行操作； u所有相邻节点都为”已完成“后，将u入栈，并标记为已完成。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution {private: // 存储有向图 vector&lt;vector&lt;int&gt; &gt; edges; // 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成 vector&lt;int&gt; visited; // 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶 vector&lt;int&gt; result; // 判断有向图中是否有环 bool valid = true;public: void dfs(int u) { // 将节点标记为「搜索中」 visited[u] = 1; // 搜索其相邻节点 // 只要发现有环，立刻停止搜索 for (int v: edges[u]) { // 如果「未搜索」那么搜索相邻节点 if (visited[v] == 0) { dfs(v); if (!valid) { return; } } // 如果「搜索中」说明找到了环 else if (visited[v] == 1) { valid = false; return; } } // 将节点标记为「已完成」 visited[u] = 2; // 将节点入栈 result.push_back(u); } vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { edges.resize(numCourses); visited.resize(numCourses); for (const auto&amp; info: prerequisites) { edges[info[1]].push_back(info[0]); } // 每次挑选一个「未搜索」的节点，开始进行深度优先搜索 for (int i = 0; i &lt; numCourses &amp;&amp; valid; ++i) { if (!visited[i]) { dfs(i); } } if (!valid) { return {}; } // 如果没有环，那么就有拓扑排序 // 注意下标 0 为栈底，因此需要将数组反序输出 reverse(result.begin(), result.end()); return result; }}; 题目279:完全平方数 描述： 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12输出: 3解释: 12 = 4 + 4 + 4.示例 2: 输入: n = 13输出: 2解释: 13 = 4 + 9. 思路一： 突破点：广度优先搜索。 步骤： 将题目抽象为从n走到0，每次跨越平方距离，求最少跨越次数； 使用BFS解决。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: /*返回小于n的平方序列: 1, 4, 9...*/ vector&lt;int&gt; getSquares(int n) { vector&lt;int&gt; res; for(int i = 1; i*i &lt;= n; ++i) { res.push_back(i*i); } return res; } int numSquares(int n) { vector&lt;int&gt; squares = getSquares(n); vector&lt;bool&gt; visited(n+1); //记录已访问过的节点 queue&lt;int&gt; q; q.push(n); int res = 0; visited[n] = true; while(!q.empty()) { int size = q.size(); res++; while(size--) { int curr = q.front(); q.pop(); /*每次跨越的间隔为平方数*/ for(int num: squares) { int next = curr - num; if(0 &gt; next) { break; } if(0 == next) { return res; } visited[next] = true; q.push(next); } } } return n; }}; 思路二： 突破点：动态规划。 步骤： 将题目理解为背包问题； 背包容量v[i]表示每个完全平方数字的大小； 背包价值w[i]为1； 求解组成数组所需要的完全平方数数量最少即为背包的价值最低。 代码： 123456789101112131415161718192021222324252627282930class Solution {public: int numSquares(int n) { vector&lt;int&gt; choices; int res = 1; // 构造物品，即所有小于给定数字的完全平方数 while (n / res &gt;= res) { choices.push_back(res * res); res++; } const int size = choices.size(); vector&lt;int&gt; dp(n + 1, 0); // init for (int i = 0; i &lt;= n; ++i) { dp[i] = i; } // 完全背包模板 for (int i = 1; i &lt; size; ++i) { for (int j = choices[i]; j &lt;= n; ++j) { dp[j] = min(dp[j], dp[j - choices[i]] + 1); } } return dp[n]; }}; 题目301:删除无效的括号 描述： 删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。 说明: 输入可能包含了除 ( 和 ) 以外的字符。 示例 1: 输入: “()())()”输出: [“()()()”, “(())()”]示例 2: 输入: “(a)())()”输出: [“(a)()()”, “(a())()”]示例 3: 输入: “)(“输出: [“”] 思路： 突破点：深度优先遍历。 步骤： 首先遍历输入字符串，获取需要删除的左右括号个数； 递归循环进行左右删除； 当1.中计数都为0时，检查输入字符串是否有效。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution {public: bool isvalid(string s) { int cnt = 0; for (auto c : s) { if (c == '(') { cnt++; } else if (c == ')') { cnt--; if (cnt &lt; 0) return false; } } return cnt == 0; } void dfs(string s, int st, int l, int r, vector&lt;string&gt;&amp; ans) { if (l == 0 &amp;&amp; r == 0) { if (isvalid(s)) { ans.push_back(s); } return; } for (int i = st; i &lt; s.size(); i++) { if (i != st &amp;&amp; s[i] == s[i-1]) continue; if (s[i] == '(' &amp;&amp; l &gt; 0) { // 删除操作，substr(a, b):从a开始个字符组成的字符串 dfs(s.substr(0, i) + s.substr(i+1, s.size()-1-i), i, l - 1, r, ans); } if (s[i] == ')' &amp;&amp; r &gt; 0) { // 删除操作，substr(a, b):从a开始个字符组成的字符串 dfs(s.substr(0, i) + s.substr(i+1, s.size()-1-i), i, l, r - 1, ans); } } } vector&lt;string&gt; removeInvalidParentheses(string s) { int left = 0; int right = 0; vector&lt;string&gt; ans; for (auto c : s) { if (c == '(') { left++; } else if (c == ')') { if (left &gt; 0) { left--; } else { right++; } } } // left和right表示左右括号要删除的个数 dfs(s, 0, left, right, ans); return ans; }};","link":"/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"},{"title":"LeetCode题目总结-Heap+Stack","text":"题目20:有效的括号 描述： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: “()”输出: true示例 2: 输入: “()[]{}”输出: true示例 3: 输入: “(]”输出: false示例 4: 输入: “([)]”输出: false示例 5: 输入: “{[]}”输出: true 思路： 突破点：使用栈模拟删除过程。 步骤： 使用栈进行存储； 当匹配到最小的括号对时，将这一对从栈中删除； 如果最后栈为空，则为有效。 代码： 123456789101112131415161718192021222324class Solution {public: bool isValid(string s) { unordered_map&lt;char,int&gt; m{{'(',1},{'[',2},{'{',3}, {')',4},{']',5},{'}',6}}; stack&lt;char&gt; st; bool isTrue = true; for(char c:s){ int flag = m[c]; if(flag&gt;=1 &amp;&amp; flag&lt;=3) { st.push(c); } else if(!st.empty() &amp;&amp; m[st.top()]==flag-3) { st.pop(); } else { isTrue = false; break; } } if(!st.empty()) { isTrue = false; } return isTrue; }}; 题目42:接雨水 描述： 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 思路一： 突破点：使用栈进行遍历。 步骤： 使用栈来跟踪可能储水的最长条形块； 如果当前条形块小于或等于栈顶条形块，则将条形块入栈； 如果当前条形块大于栈顶条形块，则暗处栈顶元素，并累加到结果中。 代码： 1234567891011121314151617int trap(vector&lt;int&gt;&amp; height) { int ans = 0, current = 0; stack&lt;int&gt; st; while (current &lt; height.size()) { while (!st.empty() &amp;&amp; height[current] &gt; height[st.top()]) { int top = st.top(); st.pop(); if (st.empty()) break; int distance = current - st.top() - 1; int bounded_height = min(height[current], height[st.top()]) - height[top]; ans += distance * bounded_height; } st.push(current++); } return ans;} 思路二： 突破点：使用双指针。 步骤： 使用双指针； 分别从左和右，更新left_max和right_max； 当发现有小值出现，则累加差值到结果中。 代码： 123456789101112131415int trap(vector&lt;int&gt;&amp; height) { int left = 0, right = height.size() - 1; int ans = 0; int left_max = 0, right_max = 0; while (left &lt; right) { if (height[left] &lt; height[right]) { height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]); ++left; } else { height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]); --right; } } return ans;} 题目71:简化路径 描述： 以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 示例 1： 输入：”/home/“输出：”/home”解释：注意，最后一个目录名后面没有斜杠。示例 2： 输入：”/../“输出：”/“解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。示例 3： 输入：”/home//foo/“输出：”/home/foo”解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。示例 4： 输入：”/a/./b/../../c/“输出：”/c”示例 5： 输入：”/a/../../b/../c//.//“输出：”/c”示例 6： 输入：”/a//b////c/d//././/..”输出：”/a/b/c” 思路一： 突破点：栈。 步骤： 需要处理三种情况： 保证路径以/进行分割； 遇到..，切换为上一级目录； 路径末尾没有/； 使用栈进行存储和遍历处理。 代码： 12345678910111213141516171819202122232425262728293031323334class Solution {public: string simplifyPath(string path) { path += \"/\"; stack&lt;string&gt; st; string dir; for (auto c : path) { // 以 / 为分隔符 if (c == '/') { // 切换上一集目录 if (dir == \"..\" &amp;&amp; !st.empty()) { st.pop(); } // 上一个 '/' 到 下一个 '/' else if (dir != \"..\" &amp;&amp; dir != \".\" &amp;&amp; !dir.empty()) { st.push(dir); } dir.clear(); } else { dir += c; } } // 遍历栈 string result; while (!st.empty()) { string s = st.top(); st.pop(); result = \"/\" + s + result; } if(result.empty()) result = \"/\"; return result; }}; 思路二： 突破点：状态机。 步骤： 分为四种状态： 前面是一个正常的字符 遇到/，则插入结果字符串中，并转至状态2； 遇到.，则转到状态2； 遇到一个正常字符，则插入结果字符串； 前面是一个/ 遇到/，直接跳过； 遇到.，转到状态3； 遇到一个正常字符，则插入结果字符串，并转到状态1； 前面是一个. 遇到/，转到状态2； 遇到.，转到状态4； 遇到一个正常字符，插入.和这个字符，并转到状态1； 前面是.. 遇到/，则回溯删除到前面一个/； 其余情况则插入一个..和当前字符，并转到状态1。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution {public: string simplifyPath(string path) { string res; // some flag to kepp state. int state = 0; // 0: last char is [char] // 1: last char is '/' // 2: last char is '.' // 3: last char is \"..\" if (path.size() != 0 &amp;&amp; path[path.size()-1]!='/') path.push_back('/'); int len = path.size(); for(int i = 0; i &lt; len; i++) { char c = path[i]; if (state == 0) { if (c == '/') { res.push_back('/'); state = 1; } else if (c == '.') state = 2; else res.push_back(c); } else if (state == 1) { if (c == '/') {} else if (c == '.') { state = 2; } else { res.push_back(c); state = 0; } } else if (state == 2) { if (c == '/') state = 1; else if (c == '.') { // '..' state = 3; } else { res.push_back('.'); res.push_back(c); state = 0; } } else if (state == 3) { if (c == '/') { // go back res.pop_back(); // pop '/' while(res.size() != 0 &amp;&amp; *res.rbegin() != '/') { res.pop_back(); // pop anthing until '/' } if (res.size() == 0) res.push_back('/'); state = 1; } else { res.push_back('.'); res.push_back('.'); res.push_back(c); state = 0; } } //cout &lt;&lt; state &lt;&lt; \" \" &lt;&lt; c &lt;&lt; \" \" &lt;&lt; res &lt;&lt; endl; } if ((state == 1 &amp;&amp; res.size() != 1)) res.pop_back(); return res; }}; 题目225: 用队列实现栈 描述： 使用队列实现栈的下列操作： push(x) – 元素 x 入栈pop() – 移除栈顶元素top() – 获取栈顶元素empty() – 返回栈是否为空注意: 你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 思路一： 突破点：单队列。 步骤： 维护队列使队头对应栈顶，队尾对应栈底； 在每次在队尾加入元素后，将原本的队列中的元素从头部取出，放入队尾，保证1的性质。 代码： 1234567891011121314151617181920212223242526272829303132333435class MyStack {public: /** Initialize your data structure here. */ MyStack() = default; /** Push element x onto stack. */ void push(int x) { que.push(x); int n = que.size(); for (int i = 0; i + 1 &lt; n; i++) { que.push(que.front()); que.pop(); } } /** Removes the element on top of the stack and returns that element. */ int pop() { int val = top(); que.pop(); return val; } /** Get the top element. */ int top() { return que.front(); } /** Returns whether the stack is empty. */ bool empty() { return que.empty(); }private: queue&lt;int&gt; que;}; 思路二： 突破点：双队列。 步骤： 创建第二个辅助队列； 第一个队列为主要的取值队列，第二个队列在pop操作时，作为拷贝辅助。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MyStack {public: queue&lt;int&gt; que1; queue&lt;int&gt; que2; // 辅助队列 /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { que1.push(x); } /** Removes the element on top of the stack and returns that element. */ int pop() { int size = que1.size(); size--; // 将que1 导入que2，但要留下最后一个元素 while (size--) { que2.push(que1.front()); que1.pop(); } // 留下的最后一个元素就是我们要返回的值 int result = que1.front(); que1.pop(); // 再将que2赋值给que1 que1 = que2; // 清空que2 while(!que2.empty()) { que2.pop(); } return result; } /** Get the top element. */ int top() { return que1.back(); } /** Returns whether the stack is empty. */ bool empty() { return que1.empty(); }}; 题目232:用栈实现队列 描述： 使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。 示例: MyQueue queue = new MyQueue(); queue.push(1);queue.push(2);queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 思路： 突破点：两个栈实现队列。 步骤： 使用两个栈，一个作为输出，一个存储输入值； 当需要pop时，判断输入栈是否为空； 若为空，导入全部输入栈数据并pop； 若不为空，直接pop（因为在peek查看元素之后，会push进输出栈）。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940class MyQueue {public: stack&lt;int&gt; stIn; stack&lt;int&gt; stOut; /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { stIn.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { //只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据） if (stOut.empty()) { // 从stIn导入数据直到stIn为空 while(!stIn.empty()) { stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } /** Get the front element. */ int peek() { int res = this-&gt;pop(); // 直接使用已有的pop函数 stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去 return res; } /** Returns whether the queue is empty. */ bool empty() { return stIn.empty() &amp;&amp; stOut.empty(); }}; 题目23:合并K个升序链表 描述： 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6示例 2： 输入：lists = []输出：[]示例 3： 输入：lists = [[]]输出：[] 思路一： 突破点：优先队列。 步骤： 建立优先队列，使得每个链表头部元素入队； 弹出后，将链表下一个元素入队。 代码： 123456789101112131415161718192021222324252627class Solution {public: // 小根堆的回调函数 struct cmp{ bool operator()(ListNode *a,ListNode *b){ return a-&gt;val &gt; b-&gt;val; } }; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pri_queue; // 建立大小为k的小根堆 for(auto elem : lists){ if(elem) pri_queue.push(elem); } // 可以使用哑节点/哨兵节点 ListNode dummy(-1); ListNode* p = &amp;dummy; // 开始出队 while(!pri_queue.empty()){ ListNode* top = pri_queue.top(); pri_queue.pop(); p-&gt;next = top; p = top; if(top-&gt;next) pri_queue.push(top-&gt;next); } return dummy.next; }}; 思路二： 突破点：两两合并。 步骤： 从头开始，两两合并链表。 代码： 123456789101112131415161718192021222324class Solution {public: // 合并两个有序链表 ListNode* merge(ListNode* p1, ListNode* p2){ if(!p1) return p2; if(!p2) return p1; if(p1-&gt;val &lt;= p2-&gt;val){ p1-&gt;next = merge(p1-&gt;next, p2); return p1; } else { p2-&gt;next = merge(p1, p2-&gt;next); return p2; } } ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { if(lists.size() == 0) return nullptr; ListNode* head = lists[0]; for(int i = 1; i&lt;lists.size(); ++i){ if(lists[i]) head = merge(head, lists[i]); } return head; }}; 思路三： 突破点：分治合并。 步骤： 从头开始，两两分治合并链表； 最后合并剩余的两个链表。 代码： 12345678910111213141516171819202122232425262728class Solution {public: // 合并两个有序链表 ListNode* merge(ListNode* p1, ListNode* p2){ if(!p1) return p2; if(!p2) return p1; if(p1-&gt;val &lt;= p2-&gt;val){ p1-&gt;next = merge(p1-&gt;next, p2); return p1; }else{ p2-&gt;next = merge(p1, p2-&gt;next); return p2; } } ListNode* merge(vector&lt;ListNode*&gt;&amp; lists, int start, int end){ if(start == end) return lists[start]; int mid = (start + end) / 2; ListNode* l1 = merge(lists, start, mid); ListNode* l2 = merge(lists, mid+1, end); return merge(l1, l2); } ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { if(lists.size() == 0) return nullptr; return merge(lists, 0, lists.size()-1); }}; 题目215:数组中的第K个最大元素 描述： 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 思路： 突破点：小顶堆。 步骤： 使用优先队列建立k大小的小顶堆，堆顶即为所求； 每次直接与堆顶元素进行判断，是否加入堆中。 代码： 1234567891011int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; for (auto n : nums) { if (pq.size() == k &amp;&amp; pq.top() &gt;= n) continue; if (pq.size() == k) { pq.pop(); } pq.push(n); } return pq.top();}","link":"/2020/09/09/2020-09-09-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Heap+Stack/"},{"title":"LeetCode题目总结-DP+Greedy","text":"题目5:最长回文子串 描述： 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 思路一：（时间超限） 突破点：反转字符串的公共子串。 步骤： 将输入的字符串反转； 求两者的公共子串； 判断该子串是否为所需的最长回文子串。 代码： 1234567891011121314151617181920212223242526272829303132333435class Solution {public: string longestPalindrome(string s) { //大小为1的字符串必为回文串 if(s.length() == 1) return s; string rev = s; string res; std::reverse(rev.begin(),rev.end()); if(rev == s) return s; //存放回文子串的长度 int len = 0; //查找s与rev的最长公共子串 for(int i=0; i&lt;s.length(); i++) { //存放待验证子串 string temp; for(int j=i; j&lt;s.length(); j++) { temp = temp+s[j]; if(len &gt;= temp.length()) { continue; } else if(rev.find(temp) != -1) {//在rev中找到temp string q = temp;//q用来验证temp是否是回文子串 std::reverse(q.begin(),q.end()); if(q == temp) { len = temp.length(); res = temp; } } else { break; } } temp=\"\"; } return res; }}; 思路二： 突破点：动态规划。 步骤： P(i, j) 表示字符串s的第i到j个字母组成的子串是否为回文串； 状态转移方程：P(i, j) = P(i+1, j-1)$\\and$ (Si == Sj)，即只有当s[i+1:j-1]是回文串，并且s的第i和j个字母相同时，s[i:j]才会是回文串； 边界条件：当长度为1时，一定为回文串，当长度为2时，若两字母相同，则为回文串。 代码： 12345678910111213141516171819202122232425class Solution {public: string longestPalindrome(string s) { int n = s.size(); vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n)); string ans; for (int l = 0; l &lt; n; ++l) { for (int i = 0; i + l &lt; n; ++i) { int j = i + l; if (l == 0) { dp[i][j] = 1; } else if (l == 1) { dp[i][j] = (s[i] == s[j]); } else { dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]); } if (dp[i][j] &amp;&amp; l + 1 &gt; ans.size()) { ans = s.substr(i, l + 1); } } } return ans; }}; 题目139: 单词拆分 描述： 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。示例 1： 输入: s = “leetcode”, wordDict = [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。示例 2： 输入: s = “applepenapple”, wordDict = [“apple”, “pen”]输出: true解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。 注意你可以重复使用字典中的单词。示例 3： 输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]输出: false 思路： 突破点：动态规划。 步骤： dp[i]表示前i个字符组成的字符串s[0…i-1]是否能够被空格拆分成若干个字典中出现的单词； 对于转移方程，我们需要枚举s[0…i-1]中的分割点j，看s[0…j-1]组成的字符串s1和s[j…i-1]组成的字符串s2是否都合法，如果均合法，则s1s2拼成的字符串也合法：dp[i] = dp[j]&amp;&amp;check(s[j...i-1])； 可通过哈希表快速判断字符串是否在给定的字符串列表里，也可以做简单剪枝，当分割点j到i的长度大于字典中最大单词长度，则返回false。 代码： 12345678910111213141516171819202122class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { auto wordDictSet = unordered_set &lt;string&gt; (); for (auto word: wordDict) { wordDictSet.insert(word); } auto dp = vector &lt;bool&gt; (s.size() + 1); dp[0] = true; for (int i = 1; i &lt;= s.size(); ++i) { for (int j = 0; j &lt; i; ++j) { if (dp[j] &amp;&amp; wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) { dp[i] = true; break; } } } return dp[s.size()]; }}; 题目140:单词拆分 II 描述： 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。 说明： 分隔时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。示例 1： 输入:s = “catsanddog”wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]输出:[ “cats and dog”, “cat sand dog”]示例 2： 输入:s = “pineapplepenapple”wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]输出:[ “pine apple pen apple”, “pineapple pen apple”, “pine applepen apple”]解释: 注意你可以重复使用字典中的单词。示例 3： 输入:s = “catsandog”wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]输出:[] 思路： 突破点：动态规划。 步骤： 首先判断能否拆分； 定义vector&lt;vector&lt;string&gt; &gt; dp(s.size() + 1, vector&lt;string&gt;())； 假设从开始到i-1个字符是如字典匹配的一个词，则第i个字符是一个新词的开头字母； 添加这个词到dp[i]中； 从第i个字符开始，如果再匹配到一个词，把dp[i]中的每个词加上空格，再加上新词，添加到后面的dp[j]中； dp[i]表示第i个字符前的所有拆分情况。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { if (!wordBreak_139(s, wordDict)) return {}; size_t validEnd = 0; vector&lt;vector&lt;string&gt; &gt; dp(s.size() + 1, vector&lt;string&gt;()); for (size_t i = 0; i &lt; s.size(); i++) { if (i == validEnd + 1) return {}; if (i != 0 &amp;&amp; dp[i].empty()) continue; for (auto&amp; word : wordDict) { size_t newEnd = i + word.size(); if (newEnd &gt; s.size()) continue; if (memcmp(&amp;s[i], &amp;word[0], word.size()) != 0) continue; validEnd = max(validEnd, newEnd); if (i == 0) { dp[newEnd].push_back(word); continue; } for (auto&amp; d : dp[i]) { dp[newEnd].push_back(d + \" \" + word); } } } return dp.back(); } bool wordBreak_139(string&amp; s, vector&lt;string&gt;&amp; wordDict){ size_t validEnd = 0; vector&lt;bool&gt; dp(s.size() + 1, false); dp[0] = true; for (size_t i = 0; i &lt; s.size(); i++) { if (i == validEnd + 1) return false; if (!dp[i]) continue; for (auto&amp; word : wordDict) { size_t newEnd = i + word.size(); if (newEnd &gt; s.size()) continue; if (memcmp(&amp;s[i], &amp;word[0], word.size()) == 0) { dp[newEnd] = true; validEnd = max(validEnd, newEnd); } } } return dp.back(); }}; 题目62:不同路径 描述： 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 示例 1: 输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右示例 2: 输入: m = 7, n = 3输出: 28 提示： 1 &lt;= m, n &lt;= 100题目数据保证答案小于等于 2 * 10 ^ 9 思路： 突破点：动态规划。 步骤： 状态方程：dp[i][j]； 状态转移方程：dp[i][j] = dp[i-1][j] +dp[i][j-1]； 边界条件：dp[0][j]全为1，dp[i][0]全为1。 代码： 123456789101112131415class Solution {public: int uniquePaths(int m, int n) { vector&lt;vector&lt;int&gt; &gt; dp(m+1, vector&lt;int&gt;(n+1)); dp[0][1] = 1; for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m][n]; }}; 题目63:不同路径 II 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径： 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 思路： 突破点：动态规划。 步骤： 状态方程：dp[i][j]表示到i, j的方法数； 状态转移方程： 如果这个位置有障碍，则dp[i][j] = 0； 如果没有障碍，则dp\\[i]\\[j] = dp\\[i-1]\\[j] + dp\\[i]\\[j-1]。 代码： 123456789101112131415161718192021class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; ob) { int n = ob.size(); if (n == 0) return 0; if (ob[0][0] == 1) return 0; int m = ob[0].size(); vector&lt;vector&lt;int&gt; &gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i ++) { for (int j = 1; j &lt;= m; j ++) { if (i == 1 &amp;&amp; j == 1) dp[i][j] = 1; else { if (ob[i-1][j-1] == 1) dp[i][j] = 0; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } } return dp[n][m]; }}; 题目121:买卖股票的最佳时机 描述： 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。示例 2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路： 突破点：动态规划。 步骤： 状态方程：dp[i]表示前i天的最大利润； 状态转移方程：dp[i] = max(dp[i-1], prices[i] - minPrice)。 代码： 123456789101112131415class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if (n == 0) return 0; // 边界条件 int minprice = prices[0]; vector&lt;int&gt; dp (n, 0); for (int i = 1; i &lt; n; i++){ minprice = min(minprice, prices[i]); dp[i] = max(dp[i - 1], prices[i] - minprice); } return dp[n - 1]; }}; 题目122:买卖股票的最佳时机 II 描述： 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2: 输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 3 * 10 ^ 40 &lt;= prices[i] &lt;= 10 ^ 4 思路： 突破点：动态规划。 步骤： 状态方程：dp[i][0]表示第i天不持有股票时的利益，dp[i][1]表示第i天持有股票时的利益； 状态转移方程：dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])，dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])。 代码： 1234567891011121314151617181920class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { // 动态规划解法 // 0.初始判断 if(prices.empty()) return 0; int dp[prices.size()][2]; // 1.初始状态 dp[0][0] = 0; dp[0][1] = -prices[0]; // 2.状态转移 for(int i = 1; i&lt;prices.size();i++){ // 3.状态转移方程 dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]); } return dp[prices.size()-1][0]; }}; 题目55:跳跃游戏 描述： 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。示例 2: 输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 思路： 突破点：贪心。 步骤： 对于可以作为起跳点的格子都做一次尝试； 更新能跳到的最远距离； 如果能调到末尾，则成功。 代码： 12345678bool canJump(vector&lt;int&gt;&amp; nums) { int k = 0; for (int i = 0; i &lt; nums.size(); i++) { if (i &gt; k) return false; k = max(k, i + nums[i]); } return true;} 题目45:跳跃游戏 II 描述：给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 1234输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。 思路： 突破点：贪心算法。 步骤： 每一次跳跃，更新下一次起跳点的范围； 在新的范围内，更新能跳到的最远距离； 记录跳跃次数，如果能到终点，则返回结果。 代码： 12345678910111213int jump(vector&lt;int&gt;&amp; nums) { int ans = 0; int end = 0; int maxPos = 0; for (int i = 0; i &lt; nums.size() - 1; i++) { maxPos = max(nums[i] + i, maxPos); if (i == end) { end = maxPos; ans++; } } return ans;}","link":"/2020/09/11/2020-09-11-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DP+Greedy/"},{"title":"LeetCode题目总结-Tree+BST","text":"题目94:二叉树的中序遍历 描述： 给定一个二叉树，返回它的中序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [1,3,2]进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 思路一： 突破点：递归。 代码： 123456void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (nullptr == cur) return; traversal(cur-&gt;left, vec); // 左 vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;right, vec); // 右} 思路二： 突破点：迭代。 代码： 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; tempStack; if (nullptr != root) tempStack.push(root); while (!tempStack.empty()) { TreeNode* node = tempStack.top(); if (nullptr != node) { // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 tempStack.pop(); // 添加右节点 if (node-&gt;right) tempStack.push(node-&gt;right); // 添加中节点 tempStack.push(node); // 中节点访问过，但是还没有处理，需要做一下标记。 tempStack.push(nullptr); // 添加左节点 if (node-&gt;left) tempStack.push(node-&gt;left); } else { // 将空节点弹出 tempStack.pop(); // 重新取出栈中元素 node = tempStack.top(); tempStack.pop(); // 加入到数组中 result.push_back(node-&gt;val); } } return result; }}; 题目144:二叉树的前序遍历 描述： 给定一个二叉树，返回它的 前序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [1,2,3]进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 思路一： 突破点：递归。 代码： 1234567891011121314class Solution {public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (nullptr == cur) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; }}; 思路二： 突破点：迭代。 代码： 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; tempStack; if (nullptr != root) tempStack.push(root); while (!tempStack.empty()) { TreeNode* node = tempStack.top(); if (nullptr != node) { tempStack.pop(); if (node-&gt;right) tempStack.push(node-&gt;right); // 右 if (node-&gt;left) tempStack.push(node-&gt;left); // 左 tempStack.push(node); // 中 tempStack.push(NULL); } else { tempStack.pop(); node = tempStack.top(); tempStack.pop(); result.push_back(node-&gt;val); } } return result; }}; 题目145:二叉树的后序遍历 描述： 给定一个二叉树，返回它的 后序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [3,2,1]进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 思路一： 突破点：递归。 代码： 1234567891011121314class Solution {public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (nullptr == cur) return; traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 vec.push_back(cur-&gt;val); // 中 } vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; }}; 思路二： 突破点：迭代。 代码： 12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; tempStack; if (nullptr != root) tempStack.push(root); while (!tempStack.empty()) { TreeNode* node = tempStack.top(); if (nullptr != node) { tempStack.pop(); tempStack.push(node); // 中 tempStack.push(NULL); if (node-&gt;right) tempStack.push(node-&gt;right); // 右 if (node-&gt;left) tempStack.push(node-&gt;left); // 左 } else { tempStack.pop(); node = tempStack.top(); tempStack.pop(); result.push_back(node-&gt;val); } } return result; }}; 题目112:路径总和 描述：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 思路一： 突破点：广度优先搜索。 步骤： 使用广度优先搜索，计算从根节点到当前节点的路径和； 使用两个队列，分别存储要遍历的节点和根节点到这些节点的路径和。 代码： 12345678910111213141516171819202122232425262728293031class Solution {public: bool hasPathSum(TreeNode *root, int sum) { if (nullptr == root) { return false; } queue&lt;TreeNode *&gt; queNode; queue&lt;int&gt; queVal; queNode.push(root); queVal.push(root-&gt;val); while (!queNode.empty()) { TreeNode *now = queNode.front(); int temp = queVal.front(); queNode.pop(); queVal.pop(); if (nullptr ==now-&gt;left &amp;&amp; nullptr == now-&gt;right) { if (temp == sum) return true; continue; } if (nullptr != now-&gt;left) { queNode.push(now-&gt;left); queVal.push(now-&gt;left-&gt;val + temp); } if (now-&gt;right != nullptr) { queNode.push(now-&gt;right); queVal.push(now-&gt;right-&gt;val + temp); } } return false; }}; 思路二： 突破点：递归。 步骤： 问题细化，即为求是否存在从当前节点的子节点到叶子节点的路径，使得路径和为sum-val； 若当前节点为叶子节点，则直接判断sum是否与val相等； 若非叶子节点，需递归进行查询。 代码： 12345678910111213class Solution {public: bool hasPathSum(TreeNode *root, int sum) { if (nullptr == root) { return false; } if (nullptr == root-&gt;left &amp;&amp; nullptr == root-&gt;right) { return sum == root-&gt;val; } return hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val); }}; 题目113:路径总和 II 描述：给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1 返回: 1234[ [5,4,11,2], [5,8,4,5]] 思路： 突破点：DFS。 步骤： 递归记录当前路径上所有节点的值； 当递归至叶子节点，计算路径总和并比较。 代码： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt; &gt; ans; void dfs(TreeNode* root, int sum, vector&lt;int&gt; valVec){ valVec.push_back(root-&gt;val); if(nullptr == root-&gt;left &amp;&amp; nullptr == root-&gt;right){ int s = 0; for(auto n: valVec) s += n; if(s == sum) ans.push_back(valVec); } if(root-&gt;left) dfs(root-&gt;left, sum, valVec); if(root-&gt;right) dfs(root-&gt;right, sum, valVec); } vector&lt;vector&lt;int&gt; &gt; pathSum(TreeNode* root, int sum) { if(root == NULL) return ans; dfs(root, sum, {}); return ans; }}; 题目235:二叉搜索树的最近公共祖先 描述： 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。 思路： 突破点：递归。 步骤： 分左右两边进行递归； 如果左边没有找到，说明公共祖先在右边； 如果右边没有找到，说明公共祖先在左边； 如果左右均不为空，则说明找到了。 代码： 12345678910111213TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //递归边界返回空或者返回存在的那个结点 if(nullptr == root || root == p || root == q) return root; //左边找一找 TreeNode* leftNode = lowestCommonAncestor(root-&gt;left,p,q); //右边找一找 TreeNode* rightNode = lowestCommonAncestor(root-&gt;right,p,q); //返回NULL或者有的那一侧 if(nullptr == leftNode)return rightNode; if(nullptr == rightNode)return leftNode; //当前祖先左边有p，右边有q return root; } 题目1382:将二叉搜索树变平衡 描述： 给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。 如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。 如果有多种构造方法，请你返回任意一种。 示例： 输入：root = [1,null,2,null,3,null,4,null,null]输出：[2,1,3,null,null,null,4]解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。 提示： 树节点的数目在 1 到 10^4 之间。树节点的值互不相同，且在 1 到 10^5 之间。 思路： 突破点：DFS。 步骤： 使用升序数组构造平衡二叉搜索树； 设长度为n，则n/2处元素为根节点； 递归进行构造。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution { void dfs(TreeNode *root, vector&lt;int&gt; &amp;vec) { if(nullptr == root) { return; } dfs(root-&gt;left, vec); vec.push_back(root-&gt;val); dfs(root-&gt;right, vec); } TreeNode* construct(const vector&lt;int&gt; &amp;vec, int leftVal, int rightVal) { if(leftVal &gt; rightVal) { return nullptr; } int mid = (leftVal+rightVal)&gt;&gt;1; auto ptr = new TreeNode(vec[mid]); ptr-&gt;right = construct(vec, mid+1, rightVal); ptr-&gt;left = construct(vec, leftVal, mid-1); return ptr; } public: TreeNode* balanceBST(TreeNode* root) { if(nullptr == root) { return nullptr; } vector&lt;int&gt; data; dfs(root, data); return construct(data, 0, data.size()-1); }};","link":"/2020/09/07/2020-09-07-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Tree+BST/"},{"title":"LeetCode题目总结-Graph","text":"题目133:克隆图 描述： 给你无向连通图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 class Node { public int val; public List neighbors;} 测试用例格式： 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。 给定节点将始终是图中的第一个节点（值为 1）。你必须将给定节点的拷贝作为对克隆图的引用返回。 示例 1： 输入：adjList = [[2,4],[1,3],[2,4],[1,3]]输出：[[2,4],[1,3],[2,4],[1,3]]解释：图中有 4 个节点。节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。示例 2： 输入：adjList = [[]]输出：[[]]解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。示例 3： 输入：adjList = []输出：[]解释：这个图是空的，它不含任何节点。示例 4： 输入：adjList = [[2],[1]]输出：[[2],[1]] 提示： 节点数不超过 100 。每个节点值 Node.val 都是唯一的，1 &lt;= Node.val &lt;= 100。无向图是一个简单图，这意味着图中没有重复的边，也没有自环。由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。图是连通图，你可以从给定节点访问到所有节点。 思路一： 突破点：深度优先遍历。 步骤： 使用一个哈希表存储所有已被访问和克隆的节点，key对应原始节点，value对应克隆图中的节点； 从给定节点开始遍历图，如果某个节点已经被访问过，则返回其克隆图中对应节点； 如果当前访问的节点不在哈希表中，则创建它的克隆节点并保存在哈希表中； 递归调用每个节点的邻接点。 代码： 12345678910111213141516171819202122232425class Solution {public: unordered_map&lt;Node*, Node*&gt; visited; Node* cloneGraph(Node* node) { if (node == nullptr) { return node; } // 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回 if (visited.find(node) != visited.end()) { return visited[node]; } // 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表 Node* cloneNode = new Node(node-&gt;val); // 哈希表存储 visited[node] = cloneNode; // 遍历该节点的邻居并更新克隆节点的邻居列表 for (auto&amp; neighbor: node-&gt;neighbors) { cloneNode-&gt;neighbors.emplace_back(cloneGraph(neighbor)); } return cloneNode; }}; 思路二： 突破点：广度优先遍历。 步骤： 使用一个哈希表存储所有已被访问和克隆的节点，key对应原始节点，value对应克隆图中的节点； 将题目给定节点添加到队列，克隆该节点并存储到哈希表中； 每次从队首取一个节点，遍历其所有邻接点； 如果某个邻接点已被访问，则从visited中取出； 否则创建新的节点进行存储； 重复操作直到队列为空。 代码： 123456789101112131415161718192021222324252627282930313233343536class Solution {public: Node* cloneGraph(Node* node) { if (node == nullptr) { return node; } unordered_map&lt;Node*, Node*&gt; visited; // 将题目给定的节点添加到队列 queue&lt;Node*&gt; Q; Q.push(node); // 克隆第一个节点并存储到哈希表中 visited[node] = new Node(node-&gt;val); // 广度优先搜索 while (!Q.empty()) { // 取出队列的头节点 auto n = Q.front(); Q.pop(); // 遍历该节点的邻居 for (auto&amp; neighbor: n-&gt;neighbors) { if (visited.find(neighbor) == visited.end()) { // 如果没有被访问过，就克隆并存储在哈希表中 visited[neighbor] = new Node(neighbor-&gt;val); // 将邻居节点加入队列中 Q.push(neighbor); } // 更新当前节点的邻居列表 visited[n]-&gt;neighbors.emplace_back(visited[neighbor]); } } return visited[node]; }}; 题目310:最小高度树 描述： 对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。 格式 该图包含 n 个节点，标记为 0 到 n - 1。给定数字 n 和一个无向边 edges 列表（每一个边都是一对标签）。 你可以假设没有重复的边会出现在 edges 中。由于所有的边都是无向边， [0, 1]和 [1, 0] 是相同的，因此不会同时出现在 edges 里。 示例 1: 输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]] 0 | 1 / \\ 2 3 输出: [1]示例 2: 输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \\ | / 3 | 4 | 5 输出: [3, 4]说明: 根据树的定义，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。树的高度是指根节点和叶子节点之间最长向下路径上边的数量。 思路： 突破点：拓扑排序。 步骤： 使用拓扑排序，不断缩小图，至只剩下1或2个点； 在一个循环中，删除无向图中入度为1的点。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public:vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt; &gt;&amp; edges) { if (n == 1) return { 0 }; else if (n == 2) return{ 0,1 }; //入度数组，并初始化 vector&lt;int&gt; indegree(n,0); vector&lt;int&gt; v; //图形表示，并初始化 vector&lt;vector&lt;int&gt; &gt; graph(n,v); //构造图与入度数组：无向图，两个点都要处理 for (int i = 0; i &lt; edges.size(); i++) { graph[edges[i][0]].push_back(edges[i][1]); graph[edges[i][1]].push_back(edges[i][0]); indegree[edges[i][0]]++; indegree[edges[i][1]]++; } //装载入度为1的queue queue&lt;int&gt; myqueue; for (int i = 0; i &lt; n; i++) { if (indegree[i] == 1) myqueue.push(i); } //！！令cnt等于myqueue.size()，一次性将入度为1的点全部删去。 int cnt = myqueue.size(); while (n&gt;2) { //一次性将入度为一的点全部删去！！不能一个一个删！ n -= cnt; while (cnt--) { int temp = myqueue.front(); myqueue.pop(); indegree[temp] = 0; //更新temp的邻接点：若temp临接点的入度为1，则将其放入queue中。 for (int i = 0; i &lt; graph[temp].size(); i++) { if (indegree[graph[temp][i]] != 0) { indegree[graph[temp][i]]--; if (indegree[graph[temp][i]] == 1)//放在这里做！只判断邻接点。 myqueue.push(graph[temp][i]); } } } cnt = myqueue.size(); } vector&lt;int&gt; result; while (!myqueue.empty()){ result.push_back(myqueue.front()); myqueue.pop(); } return result;}}; 题目332:重新安排行程 描述： 给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。 提示： 如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前所有的机场都用三个大写字母表示（机场代码）。假定所有机票至少存在一种合理的行程。所有的机票必须都用一次 且 只能用一次。 示例 1： 输入：[[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]输出：[“JFK”, “MUC”, “LHR”, “SFO”, “SJC”]示例 2： 输入：[[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]输出：[“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]解释：另一种有效的行程是 [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”]。但是它自然排序更大更靠后。 思路一： 突破点：Hierholzer 算法（寻找欧拉路径）。 步骤： 从起点出发，进行深度优先搜索； 每次沿着某条边从某个顶点移动到另外一个顶点时，删除这条边； 如果没有可移动的路径，则将所在节点加入栈并返回； 对于出入度差为1的节点，可能产生死胡同，最后入栈。 代码： 12345678910111213141516171819202122232425class Solution {public: unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, std::greater&lt;string&gt; &gt; &gt; vec; vector&lt;string&gt; stk; void dfs(const string&amp; curr) { while (vec.count(curr) &amp;&amp; vec[curr].size() &gt; 0) { string tmp = vec[curr].top(); vec[curr].pop(); dfs(move(tmp)); } stk.emplace_back(curr); } vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt; &gt;&amp; tickets) { for (auto&amp; it : tickets) { vec[it[0]].emplace(it[1]); } dfs(\"JFK\"); reverse(stk.begin(), stk.end()); return stk; }}; 思路二： 突破点：回溯。 步骤： 使用unordered_map记录城市间的映射； 回溯遍历时，遇到的机场个数达到航班数量+1，则终止回溯。 代码： 123456789101112131415161718192021222324252627282930class Solution {private:// unordered_map&lt;出发城市, map&lt;到达城市, 航班次数&gt;&gt; targetsunordered_map&lt;string, map&lt;string, int&gt; &gt; targets;bool backtracking(int ticketNum, vector&lt;string&gt;&amp; result) { if (result.size() == ticketNum + 1) { return true; } for (pair&lt;const string, int&gt;&amp; target : targets[result[result.size() - 1]]) { if (target.second &gt; 0 ) { // 使用int字段来记录到达城市是否使用过了 result.push_back(target.first); target.second--; if (backtracking(ticketNum, result)) return true; result.pop_back(); target.second++; } } return false;}public: vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) { vector&lt;string&gt; result; for (const vector&lt;string&gt;&amp; vec : tickets) { targets[vec[0]][vec[1]]++; // 记录映射关系 } result.push_back(\"JFK\"); backtracking(tickets.size(), result); return result; }}; 题目684:冗余连接 描述： 在本问题中, 树指的是一个连通且无环的无向图。 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。 示例 1： 输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为: 1 / 2 - 3示例 2： 输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]输出: [1,4]解释: 给定的无向图为:5 - 1 - 2 | | 4 - 3注意: 输入的二维数组大小在 3 到 1000。二维数组中的整数在1到N之间，其中N是输入数组的大小。 思路： 突破点：并查集。 步骤： 遍历所有边，将连通的节点放入同一个集合，形成连通分量； 遍历过程中，如果某一边的两个节点已经属于同一连通分量，则为冗余边。 代码： 1234567891011121314151617181920212223242526272829303132class Solution {private: int parent[1001]; int find_root(int x) { while (parent[x] != x) { parent[x] = parent[parent[x]]; x = parent[x]; } return x; } bool union_root(int x, int y) { int root_x = find_root(x); int root_y = find_root(y); if (root_x == root_y) { return false; } parent[root_x] = root_y; return true; } public: vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) { for (int i = 1; i &lt;= 1000; i++) { parent[i] = i; } for (auto edge : edges) { if (!union_root(edge[0], edge[1])) { return edge; } } return {}; }}; 题目685:冗余连接 II 描述： 在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。 输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。 返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。 示例 1: 输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的有向图如下: 1 / v v2–&gt;3示例 2: 输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]输出: [4,1]解释: 给定的有向图如下:5 &lt;- 1 -&gt; 2 ^ | | v 4 &lt;- 3注意: 二维数组大小的在3到1000范围内。二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。 思路： 突破点：并查集。 步骤： 遍历一遍寻找入读为2的点，记录为root； 遍历第二遍，将非指向root的边用并查集合并，指向root的边用数组记录； 遍历数组记录的点，判断该点是否与root指向同一点； 若不是，说明没有联通，进行合并； 若指向同一点，说明[该点, root]的边冗余，可以删去； 当入度全为1， 返回环中最后出现的边即可。 代码： 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int pre[1005],ind[1005]; int find(int x){ return pre[x]==x?x:pre[x]=find(pre[x]); } vector&lt;int&gt; findRedundantDirectedConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) { int n=edges.size(),root=-1; vector&lt;int&gt; v; for(int i=1;i&lt;=n;++i) pre[i]=i; for(auto i:edges){ ind[i[1]]++; if(ind[i[1]]==2) root=i[1]; } if(root == -1) { for(auto i : edges) { int a = find(i[0]), b = find(i[1]); if(a != b) pre[b] = a; else return i; } } for(auto i:edges){ if(i[1]!=root){ pre[find(i[1])]=find(i[0]); } else v.emplace_back(i[0]); } if(find(root)!=find(v[0])) return {v[1],root}; else return {v[0],root}; }};","link":"/2020/09/12/2020-09-12-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Graph/"},{"title":"LeetCode题目总结-Recursion+Backtrack","text":"题目17:电话号码的字母组合 描述： 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射与电话按键相同。注意 1 不对应任何字母。 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 思路： 突破点：回溯。 步骤： 维护一个字符串，表示已有的字母排列； 每次取一个数字，从哈希表中获取可能字母； 将一个字母插入到已有排列后面； 处理下一个数字，直到得到完整排列。 代码： 123456789101112131415161718192021222324252627282930313233343536class Solution {public: vector&lt;string&gt; letterCombinations(string digits) { vector&lt;string&gt; combinations; if (digits.empty()) { return combinations; } unordered_map&lt;char, string&gt; phoneMap{ {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; string combination; backtrack(combinations, phoneMap, digits, 0, combination); return combinations; } void backtrack(vector&lt;string&gt;&amp; combinations, const unordered_map&lt;char, string&gt;&amp; phoneMap, const string&amp; digits, int index, string&amp; combination) { if (index == digits.length()) { combinations.push_back(combination); } else { char digit = digits[index]; const string&amp; letters = phoneMap.at(digit); for (const char&amp; letter: letters) { combination.push_back(letter); backtrack(combinations, phoneMap, digits, index + 1, combination); combination.pop_back(); } } }};","link":"/2020/09/15/2020-09-15-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Recursion+Backtrack/"},{"title":"LeetCode题目总结-Queue+TopologicalSort","text":"题目621:任务调度器 描述： 给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。 示例 ： 输入：tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2输出：8解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 提示： 任务的总个数为 [1, 10000]。n 的取值范围为 [0, 100]。 思路： 突破点：桶思想。 步骤： 建立大小为n+1的桶，个数为数量最多的任务； 每个桶视为一轮任务； 总排队时间=(桶个数-1)*(n+1)+最后一个桶的任务数； 代码： 123456789101112int leastInterval(vector&lt;char&gt;&amp; tasks, int n) { int len=tasks.size(); vector&lt;int&gt; vec(26); for(char c:tasks) ++vec[c-'A']; sort(vec.begin(),vec.end(),[](int&amp; x,int&amp;y){return x&gt;y;}); int cnt=1; while(cnt&lt;vec.size()&amp;&amp;vec[cnt]==vec[0]) cnt++; return max(len,cnt+(n+1)*(vec[0]-1) ); } 题目641:设计循环双端队列 描述： 设计实现双端队列。你的实现需要支持以下操作： MyCircularDeque(k)：构造函数,双端队列的大小为k。insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。isEmpty()：检查双端队列是否为空。isFull()：检查双端队列是否满了。示例： MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3circularDeque.insertLast(1); // 返回 truecircularDeque.insertLast(2); // 返回 truecircularDeque.insertFront(3); // 返回 truecircularDeque.insertFront(4); // 已经满了，返回 falsecircularDeque.getRear(); // 返回 2circularDeque.isFull(); // 返回 truecircularDeque.deleteLast(); // 返回 truecircularDeque.insertFront(4); // 返回 truecircularDeque.getFront(); // 返回 4 提示： 所有值的范围为 [1, 1000]操作次数的范围为 [1, 1000]请不要使用内置的双端队列库。 思路： 突破点：双端链表。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class MyCircularDeque {public: struct DLNode { int val; DLNode* next; DLNode* prev; DLNode() : val(-1), next(NULL), prev(NULL) {} DLNode(int v) : val(v), next(NULL), prev(NULL) {} }; int size; int capacity; DLNode* head; DLNode* tail; /** Initialize your data structure here. Set the size of the deque to be k. */ MyCircularDeque(int k) { size = 0; capacity = k; head = new DLNode(); tail = new DLNode(); head-&gt;next = tail; tail-&gt;prev = head; } /** Adds an item at the front of Deque. Return true if the operation is successful. */ bool insertFront(int value) { if (isFull()) return false; auto node = new DLNode(value); node-&gt;prev = head; node-&gt;next = head-&gt;next; node-&gt;next-&gt;prev = node; node-&gt;prev-&gt;next = node; ++size; return true; } /** Adds an item at the rear of Deque. Return true if the operation is successful. */ bool insertLast(int value) { if (isFull()) return false; auto node = new DLNode(value); node-&gt;prev = tail-&gt;prev; node-&gt;next = tail; node-&gt;prev-&gt;next = node; node-&gt;next-&gt;prev = node; ++size; return true; } /** Deletes an item from the front of Deque. Return true if the operation is successful. */ bool deleteFront() { if (isEmpty()) return false; auto node = head-&gt;next; node-&gt;next-&gt;prev = node-&gt;prev; node-&gt;prev-&gt;next = node-&gt;next; delete node; node = NULL; --size; return true; } /** Deletes an item from the rear of Deque. Return true if the operation is successful. */ bool deleteLast() { if (isEmpty()) return false; auto node = tail-&gt;prev; node-&gt;next-&gt;prev = node-&gt;prev; node-&gt;prev-&gt;next = node-&gt;next; delete node; node = NULL; --size; return true; } /** Get the front item from the deque. */ int getFront() { return head-&gt;next-&gt;val; } /** Get the last item from the deque. */ int getRear() { return tail-&gt;prev-&gt;val; } /** Checks whether the circular deque is empty or not. */ bool isEmpty() { return size == 0; } /** Checks whether the circular deque is full or not. */ bool isFull() { return size == capacity; }}; 题目622:设计循环队列 描述： 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 示例： MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 提示： 所有的值都在 0 至 1000 的范围内；操作数将在 1 至 1000 的范围内；请不要使用内置的队列库。 思路： 突破点：下标%数组大小。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class MyCircularQueue {private: int start; int end; int count; vector&lt;int&gt; nums; public: /** Initialize your data structure here. Set the size of the queue to be k. */ MyCircularQueue(int k): start(0), end(0), count(0) { nums.resize(k); } /** Insert an element into the circular queue. Return true if the operation is successful. */ bool enQueue(int value) { if (count == nums.size()) return false; nums[start++] = value; start %= nums.size(); ++count; return true; } /** Delete an element from the circular queue. Return true if the operation is successful. */ bool deQueue() { if (count == 0) return false; nums[end++] = 0; end %= nums.size(); --count; return true; } /** Get the front item from the queue. */ int Front() { if (count == 0) return -1; return nums[end]; } /** Get the last item from the queue. */ int Rear() { if (count == 0) return -1; return nums[(start - 1 + nums.size()) % nums.size()]; } /** Checks whether the circular queue is empty or not. */ bool isEmpty() { return count == 0; } /** Checks whether the circular queue is full or not. */ bool isFull() { return nums.size() == count; }}; 题目329:矩阵中的最长递增路径 描述： 给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。 示例 1: 输入: nums =[ [9,9,4], [6,6,8], [2,1,1]]输出: 4解释: 最长递增路径为 [1, 2, 6, 9]。示例 2: 输入: nums =[ [3,4,5], [3,2,6], [2,2,1]]输出: 4解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。 思路一： 突破点：优化的深度优先搜索。 步骤： 将矩阵视为有向图，若相邻两个单元格大小不等，则在两相邻单元格中存在一条小值指向大值的有向边； 在有向图中，寻找最长路径； 从一个单元格开始DFS，直到搜索结束； 使用缓存矩阵优化，已经计算过的单元格进行保存。 代码： 1234567891011121314151617181920212223242526272829303132333435class Solution {public: static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; int rows, columns; int longestIncreasingPath(vector&lt; vector&lt;int&gt; &gt; &amp;matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) { return 0; } rows = matrix.size(); columns = matrix[0].size(); auto memo = vector&lt; vector&lt;int&gt; &gt; (rows, vector &lt;int&gt; (columns)); int ans = 0; for (int i = 0; i &lt; rows; ++i) { for (int j = 0; j &lt; columns; ++j) { ans = max(ans, dfs(matrix, i, j, memo)); } } return ans; } int dfs(vector&lt; vector&lt;int&gt; &gt; &amp;matrix, int row, int column, vector&lt; vector&lt;int&gt; &gt; &amp;memo) { if (memo[row][column] != 0) { return memo[row][column]; } ++memo[row][column]; for (int i = 0; i &lt; 4; ++i) { int newRow = row + dirs[i][0], newColumn = column + dirs[i][1]; if (newRow &gt;= 0 &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= 0 &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) { memo[row][column] = max(memo[row][column], dfs(matrix, newRow, newColumn, memo) + 1); } } return memo[row][column]; }}; 思路二： 突破点：拓扑排序+动态规划。 步骤： 状态转移方程：memo[i][j] = max{memo[x][y]} + 1，(x, y)与(i, j)相邻，且matrix[x][y]&gt;matrix[i][j]； 使用拓扑排序，从所有出度为0的单元格开始DFS； 更新其余单元格出度，并将出度为0的加入下一层搜索； 搜索结束后，总层数即为所求答案。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; int rows, columns; int longestIncreasingPath(vector&lt; vector&lt;int&gt; &gt; &amp;matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) { return 0; } rows = matrix.size(); columns = matrix[0].size(); auto outdegrees = vector&lt; vector&lt;int&gt; &gt; (rows, vector &lt;int&gt; (columns)); for (int i = 0; i &lt; rows; ++i) { for (int j = 0; j &lt; columns; ++j) { for (int k = 0; k &lt; 4; ++k) { int newRow = i + dirs[k][0], newColumn = j + dirs[k][1]; if (newRow &gt;= 0 &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= 0 &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[i][j]) { ++outdegrees[i][j]; } } } } queue &lt; pair&lt;int, int&gt; &gt; q; for (int i = 0; i &lt; rows; ++i) { for (int j = 0; j &lt; columns; ++j) { if (outdegrees[i][j] == 0) { q.push({i, j}); } } } int ans = 0; while (!q.empty()) { ++ans; int size = q.size(); for (int i = 0; i &lt; size; ++i) { auto cell = q.front(); q.pop(); int row = cell.first, column = cell.second; for (int k = 0; k &lt; 4; ++k) { int newRow = row + dirs[k][0], newColumn = column + dirs[k][1]; if (newRow &gt;= 0 &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= 0 &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &lt; matrix[row][column]) { --outdegrees[newRow][newColumn]; if (outdegrees[newRow][newColumn] == 0) { q.push({newRow, newColumn}); } } } } } return ans; }}; 题目1203:项目管理 描述： 公司共有 n 个项目和 m 个小组，每个项目要不没有归属，要不就由其中的一个小组负责。 我们用 group[i] 代表第 i 个项目所属的小组，如果这个项目目前无人接手，那么 group[i] 就等于 -1。（项目和小组都是从零开始编号的） 请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表： 同一小组的项目，排序后在列表中彼此相邻。项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。结果要求： 如果存在多个解决方案，只需要返回其中任意一个即可。 如果没有合适的解决方案，就请返回一个 空列表 示例 1： 输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]输出：[6,3,4,1,5,2,0,7]示例 2： 输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]输出：[]解释：与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。 提示： 1 &lt;= m &lt;= n &lt;= 3*10^4group.length == beforeItems.length == n-1 &lt;= group[i] &lt;= m-10 &lt;= beforeItems[i].length &lt;= n-10 &lt;= beforeItems[i][j] &lt;= n-1i != beforeItems[i][j] 思路： 突破点：拓扑排序。 步骤： 将组别为-1的项目都创建一个新组； 遍历beforeItems[i][j]数组； 如果i和j属于同组，则确定组内优先级关系； 若不同组，则确定小组间优先级关系； 对每个组内拓扑排序； 对不同组拓扑排序。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103class Solution {public: //拓扑排序的节点结构体声明struct tpnod { //组外的优先级比该节点小的节点索引，维护不同的小组排序后的优先级关系 vector&lt;int&gt;next1; //组内的优先级比该节点小的节点索引，维护同一小组的任务排序后的优先级关系 vector&lt;int&gt;ingnext; //不同组间的在完成该节点之前需要完成的任务数 int deg = 0; //组内的在完成该节点之前需要完成的任务数 int igdeg = 0;}; tpnod nos[30001];//小组的数组，每个单元都是一个小组，可能不只m个，因为新创建了一些小组，但一定不会超过30000；tpnod itogroup[30001];//维护同一个组的项目vector&lt;int&gt;grouptoi[30001];//维护同一组的不同项目之间的顺序vector&lt;int&gt;ingroup[30001]; vector&lt;int&gt; sortItems(int n, int m, vector&lt;int&gt;&amp; group, vector&lt;vector&lt;int&gt;&gt;&amp; beforeItems) { //numOfG为包括创建的新组的组数 int numOfG = m; vector&lt;int&gt;res; for (int i = 0; i &lt; group.size(); i++) { if (group[i] != -1) grouptoi[group[i]].push_back(i); //否则创建新组 else { grouptoi[numOfG].push_back(i); group[i] = numOfG; numOfG++;//创建后加一 } } for (int i = 0; i &lt; beforeItems.size(); i++) { for (int j = 0; j &lt; beforeItems[i].size(); j++) { //在同一组就看作组内项目优先级关系 if (group[beforeItems[i][j]] == group[i]) nos[i].igdeg++, nos[beforeItems[i][j]].next1.push_back(i); //在不同组就看作组之间的优先级关系，因为同组的肯定是聚在一起的 else itogroup[group[i]].deg++, itogroup[group[beforeItems[i][j]]].next1.push_back(group[i]); } } //确定不同小组组内项目优先级顺序 for (int i = 0; i &lt; numOfG; i++) { queue&lt;int&gt;q; for (int j = 0; j &lt; grouptoi[i].size(); j++) { if (nos[grouptoi[i][j]].igdeg == 0) q.push(grouptoi[i][j]); } int cnt2 = 0; while (!q.empty()) { cnt2++; int tp2 = q.front(); ingroup[i].push_back(tp2); q.pop(); for (int j = 0; j &lt; nos[tp2].next1.size(); j++) { nos[nos[tp2].next1[j]].igdeg--; //在该节点之前的工作处理完了就把该节点放入队列 if (nos[nos[tp2].next1[j]].igdeg == 0) q.push(nos[tp2].next1[j]); } } //判断是否矛盾 if (cnt2 != grouptoi[i].size()) { //res此时为空 return res; } } queue&lt;int&gt;q; for (int i = 0; i &lt; numOfG; i++) if (itogroup[i].deg == 0) q.push(i); int cnt3 = 0; int tp7; vector&lt;int&gt;grorder; //之前已经处理好了不同小组优先级关系，现在开始确定不同小组的顺序。 while (!q.empty()) { tp7 = q.front(); grorder.push_back(tp7); q.pop(); cnt3++; for (int i = 0; i &lt; itogroup[tp7].next1.size(); i++) { (itogroup[itogroup[tp7].next1[i]].deg)--; if (itogroup[itogroup[tp7].next1[i]].deg == 0) q.push(itogroup[tp7].next1[i]); } } //判断是否矛盾 if (cnt3 != numOfG) { //res为空 return res; } for (int i = 0; i &lt; numOfG; i++) { for (int j = 0; j &lt; ingroup[grorder[i]].size(); j++) res.push_back(ingroup[grorder[i]][j]); } return res; }};","link":"/2020/09/12/2020-09-12-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Queue+TopologicalSort/"},{"title":"Diff Array","text":"In this blog, we will talk about one trick can be used to solve problems to do with frequent addition and subtraction to a subsection of an array - Diff Array. FunctionalityTodo with frequent addition and subtraction to a subsection of an array. e.g. Given array arr, add 1 for elements between arr[0] and arr[3] inclusively, then, substract 3 for elements between arr[2] and arr[5] inclusively, what will be the final arr. Trick##Constracting a diff array Diff array is an array recording the difference between two adjacent elements in arr, i.e. diffArr[i] = arr[i] - arr[i-1]. 12345vector&lt;int&gt; diffArr(arr.size());diffArr[0] = arr[0];for (int i = 0; i &lt; arr.size(); i++) { diffArr[i] = arr[i] - arr[i-1];} Recovering original arrayTo recover arr from diffArr, we are going to add elements in diffArr with previous elements (one element before) in arr. 12345vecotr&lt;int&gt; result(diffArr.size());result[0] = diffArr[0];for (int i = 1; i &lt; diffArr.size(); i++) { result[i] = result[i-1]+diff[i];} Opearting a diff arrayWith method mentioned in previous section, to add or substract amount for elements between arr[a] and arr[b] inclusively, we just need diffArr[a] += amount and diffArr[b+1] -= amount. Remember to check b+1 if it excesses the boundary of array,","link":"/2020/11/08/2020-11-08-Diff-Array/"},{"title":"Linux知识点总结","text":"1. find命令 查找指定文件名文件（不区分大小写）： 1find -iname \"ProgramToFind.java\" 对找到的文件执行某命令 1find -iname \"ProgramToOperate.java\" -exec md5sum {} \\; 查找home目录下所有空文件 1find ~ -empty 在/home下找到大小超过3MB的文件 1find /home -type f -size +3072k 2. static和const关键字 static：存储在静态存储区，未初始化时自动初始化为0： 局部变量： 变为静态局部变量； 作用域仍为局部作用域； 离开作用域仍驻留在内存中，但不可访问； 全局变量： 变为全局静态变量； 在声明的文件之外不可见； 成员变量： 变为类的全局变量，被类的对象共享，包括派生类的对象； 必须在类外进行初始化，如int base::var = 10;，但可以用const修饰static数据成员，从而在类内初始化； 成员函数： 使得成员函数为所有对象共享，不含this指针； 可以独立访问，不需要创建实例，如base::func(3, 5); 不可直接引用类的非静态成员，但是可以引用静态成员； 不可同时用const和static修饰成员函数（const含this指针，static不含，冲突）； const： 表明变量不可修改； 限定成员函数不可修改任何数据成员； const与指针： const char *p：指向的内容不能改变； char * const p：将p声明为常指针，地址不能变，但是内容可变。 3. C++的内存分区 栈区（stack）：主要存放函数参数以及局部变量，由系统自动分配释放； 堆区（heap）：用户通过malloc/new手动申请释放，分配类似链表； 全局/静态区：存放全局变量、静态变量； 字符串常量区：字符串常量； 代码区：程序的二进制代码。 4. STL容器 底层数据结构： vector：数组； map、multimap：红黑树； unordered_map、unordered_nultimap：哈希表。 5. 内存泄漏 一般为堆内存泄漏，即程序在运行中动态申请的内存空间不使用后，未及时释放； 解决： 良好编程习惯； 重载new和delete，以链表形式自动管理分配的内存； 使用智能指针。 6. 32位、64位系统中，常用内置数据类型所占字节数 32位： char：1字节； 指针变量：4字节； short int：2字节； int：4字节； unsigned int：4字节； float：4字节； double：8字节； long：4字节； unsigned long：4字节； long long：8字节； 64位： char：1字节； 指针变量：8字节； short int：2字节； int：4字节； unsigned int：4字节； float：4字节； double：8字节； long：8字节； unsigned long：8字节； long long：8字节。 7. inline、volatile关键字 inline：解决频繁调用小函数大量消耗栈空间的问题； volatile：表明类型变量可悲更改，不再优化，需要从如内存中重新读取。 8. 深拷贝与浅拷贝 拷贝函数使用场景： 一个对象以值的方式传入函数体； 一个对象以值的方式从函数返回； 一个对象需通过另一个对象进行初始化； 区别： 浅拷贝：只是增加一个指针指向已存在的内存地址； 深拷贝：增加一个指针，并且申请一个新的内存用于存放复制的对象。 9. 派生类构造/析构函数调用顺序 构造函数：先基后派； 析构函数：先派后基。 10. 数据成员初始化顺序 顺序： 基类的静态变量或全局变量； 派生类的静态变量或全局变量； 基类的成员变量； 派生类的成员变量。 11. static_cast, dynamic_cast, const_cast, reinpreter_cast区别 static_cast与dynamic_cast： 发生时间不同，一个是static编译时，一个是runtime运行时； static_cast为强制类型转换，不提供运行时的检查； dynamic_cast用于转换指针和引用，不可用于转换对象，主要用于类层次间的上行和下行转换： 上行转换：B继承自A，由B转换为A； 下行转换：B继承自A，A转换为B； 上行转换时，static_cast和dynamic_cast效果相同，下行转换时，dynamic_cast具有类型检查，更安全。 12. 定义一个空类 编译器会做什么 当用到相关函数时，编译器会去自动生成：默认构造函数、默认拷贝构造函数、默认拷贝赋值操作符、默认析构函数； 所有自动生成的函数都是inline和public的。 13. 哪些函数不能成为虚函数 构造函数：假如子类继承基类构造函数，则子类对象将使用基类构造函数构造，而积累的构造函数并不知道自类的成员，不符合语义，且，多态是通过基类指针指向子类对象实现多态的，在对象构造之前，并没有对象产生，因此无法使用多态特性，是矛盾的； 内联成员函数：内联函数在编译时展开，而虚函数是在运行时绑定的，两者相违背； 静态成员函数：在编译时确定，无法动态绑定，不支持多态。 14. 内联函数与宏定义的区别 宏定义在于处理时把所有宏名用宏体替换，内联函数在编译时进行代码插入、展开、省去调用的开销； 宏定义没有类型检查，内联函数满足函数的性质，如有返回值、参数列表等。 15. 左值引用和右值引用 左值引用要求右边的值必须能够取地址，如果不能取地址，可以使用常引用； 例：const int &amp;var = 10;等价于 const int temp = 10; const int &amp;var = temp; &lt;!--￼4--&gt; 注意：返回一个从pos开始，包含pos的n个字符，pos默认值为0，n默认值为s.size()-pos。","link":"/2020/09/28/2020-09-28-Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/04/14/hello-world/"},{"title":"FD.io简介","text":"总结自fd.io Youtube 关于datapath的创新 “Innovating the sh.. out of the datapath” FD.io解决的问题就目前来看，相比controlplane，dataplane得到的发展更受局限，我们少有具有推动性的或特性丰富的dataplane，从而导致了数据中心相关创新的缺乏。我们亟需一个灵活的高性能可编程dataplane，所以fd.io，或者说VPP，出现了。 现有dataplane的缺陷当然，现在已经有一些人在做相关dataplane的尝试，但是这些产品总是存在一些不足的点，比如在可扩展性和稳定性方面的不足、缺少跨平台的能力等。这些能力都是很重要的点，比如对于跨平台来说，我们希望dataplane可以在VM上运行，同时也能够通过容器运行。 FD.io的简单介绍与DPDK的关系对于IO来说，主要依赖于DPDK的实现，可以理解为在DPDK上层叠加包处理和管理的能力，从而达到把DPDK集成到多种环境（比如SDN）中的目的。 关于VPPVPP全称是Vector Packet Processor，最初是在Cisco内部于2002年开始创立，一共有300,000行左右代码，现在捐赠给了FD.io。可用于L3网络（IPv4/IPv6）、MPLS、SR和L2网络，是一个高度可编程的多功能数据平面。高度可编程和多功能主要体现在VPP允许以插件的方式进行集成，每个插件可以视为一个小的子项目，多个插件的开发增强了VPP的能力，这也使得VPP甚至可以被用于代替vSwitch、vRouter、vFirewall等。 VPP的能力表现是比较稳定的，和包大小、FIB大小、路由数量无关，对比来看OVSDPDK收FIB大小影响极大。","link":"/2021/04/26/2021-04-26-FDio%E7%AE%80%E4%BB%8B/"},{"title":"Command Line Related Notes","text":"1. Switch to end of line in vi:1shift+G 2. Switch to end of line in normal command line:1ctrl+E 3. Switch to specific line in target file:1vi &lt;file directory&gt; +&lt;n&gt; 4. Look up for filesystems of disk:1df -h 5. Look up for files in disk:1du 6. Look up with letter case ignored:1grep -i 7. Look up for CPU info:1htop 8. Switch to start of line in normal command line:1ctrl+A 9. Delete one fragment in normal command line:1ctrl+W 10. Delete one line in vi:double click D 11. Redo in vi:double click U 12. for loop for batch processing1for i in `docker image ls`; do echo \"$i\"; done","link":"/2021/06/05/2021-06-05-Command-Line-Related-Notes/"},{"title":"K8s and docker Related Notes","text":"1. Management tools for clusters, pods, deployments, etc. :k9s 2. When not able to delete resources in k8s:First edit resource: 1kubectl edit &lt;resource name&gt; then delete the finalizer part and try again. 3. filtering docker images1docker image \"name*\" 4. save and load docker images12docker image save &gt; smartcity_imagesdocker image load &lt; smartcity_images 5. getting k8s events1kubectl get events","link":"/2021/06/05/2021-06-05-K8s-and-docker-Related-Notes/"},{"title":"VM Related Notes","text":"1. List all VMs:1virsh list 2. List network setting xml:1virsh net-dumpxml &lt;network&gt; 3. list and revert vm from snapshots:12virsh snapshot-list 476virsh snapshot-revert --domain freebsd --snapshotname 5Sep2016_S1 --running","link":"/2021/06/05/2021-06-05-VM-Related%20-Notes/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"FD.io","slug":"FD-io","link":"/tags/FD-io/"},{"name":"Notes","slug":"Notes","link":"/tags/Notes/"},{"name":"Cent OS","slug":"Cent-OS","link":"/tags/Cent-OS/"},{"name":"Command Line","slug":"Command-Line","link":"/tags/Command-Line/"},{"name":"K8s","slug":"K8s","link":"/tags/K8s/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"VM","slug":"VM","link":"/tags/VM/"}],"categories":[{"name":"知识点","slug":"知识点","link":"/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"云计算","slug":"云计算","link":"/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"Notes","slug":"Notes","link":"/categories/Notes/"}]}