{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/04/14/hello-world/"},{"title":"KMP Algorithm","text":"Background…Once upon a time, Tom asked his father to find abab inside abcaabababaa. Tom’s dad did this in a traditional way (brute force). He compared each character of the first string with each character of the second string. When he find one character not matching, for example, the third character in the second string in this case, he start again from the second character of the second string. It went on and on and on… Moving on…Unfortunately, Tom had a bad temper about waiting. He wanted to make some change. Tom noticed that, if the n-th character in the first string happened to be not match, even if he start again, he will make a compare with that character again in the future. Therefore, Tom decided not to start from the begining each time a not match is found. He talked to his dad, “when we have a not match for the n-th character, if we consider the characters before, we do have a big match, and if so, we actually can use the head of abab to try to match the tail of abab, the longest mathing substring will be the place for us to start again.” For example, for abab, there will be 3 possible heads: a, ab, aba. And there will be 3 possible tails: b, ab, bab. The longest matching is ab, so each time there’s a not mathing, we don’t need to start from begin, instead we can start from the 3-rd character to make a comparison. Coding work…Taking the above thought into real code, c++, for example: We first need a function to generate all the longest matching for each substring of the string we are trying to search. 1234567891011121314151617int * FindLongestMatching(string first){ int * tableOfFirst = new int[first.length()]; tableOfFirst[0] = -1; int i = 0; int j = -1; while (i &lt; p.length() - 1) { if (j == -1 || first[i] == first[j]) { i++； j++； tableOfFirst[i] = j; } else { j = tableOfFirst[j]; } } return tableOfFirst;} With this function, we can make a linear time matching: 123456789101112131415161718int KMP (string first, string second) { int i = 0; int j = 0; int * tableOfFirst = FindLongestMatching(first); while (i &lt; second.length() &amp;&amp; j &lt; first.length()) { if (j == -1 || second[i] == first[j]) { i++; j++; } else { j = tableOfFirst[j]; } } if (j == first.length()){ return i-j; } return -1;} Tom is happy now.","link":"/2020/04/17/2020-04-17-KMP-Algorithm/"},{"title":"Sorting Algorithms - Summary","text":"In this series of blogs, we will talk about different sorting algorithms. All the algorithms in the table below will be covered. Algorithm Time Complexity (Average Case) Time Complexity (Worst Case) Time Complexity (Best Case) Merg Stability Bubble Sort O(N^2) O(N^2) O(N^2) O(1) Stable Quick Sort O(NlogN) O(N^2) O(NlogN) O(logN) Not Stable Quick Sort (with Random Selection) O(NlogN) O(NlogN) O(NlogN) O(logN) Not Stable Insertion Sort O(N^2) O(N^2) O(N) O(1) Stable Selection Sort O(N^2) O(N^2) O(N^2) O(1) Not Stable Heap Sort O(NlogN) O(NlogN) O(NlogN) O(1) Not Stable Merge Sort (with double divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Merge Sort (with multi divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Counting Sort O(N+M) O(N+M) O(N+M) O(N+M) Stable Bucket Sort O(N+M) O(N^2) O(N+M) O(N+M) Stable Radix Sort O(N*M) O(N*M) O(N*M) O(N+M) Stable","link":"/2020/04/21/2020-04-21-Sorting-Algorithms---Summary/"},{"title":"Sorting Algorithms - Bubble Sort","text":"In this series of blogs, we will talk about different sorting algorithms. All the algorithms in the table below will be covered. Algorithm Time Complexity (Average Case) Time Complexity (Worst Case) Time Complexity (Best Case) Merg Stability Bubble Sort O(N^2) O(N^2) O(N^2) O(1) Stable Quick Sort O(NlogN) O(N^2) O(NlogN) O(logN) Not Stable Quick Sort (with Random Selection) O(NlogN) O(NlogN) O(NlogN) O(logN) Not Stable Insertion Sort O(N^2) O(N^2) O(N) O(1) Stable Selection Sort O(N^2) O(N^2) O(N^2) O(1) Not Stable Heap Sort O(NlogN) O(NlogN) O(NlogN) O(1) Not Stable Merge Sort (with double divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Merge Sort (with multi divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Counting Sort O(N+M) O(N+M) O(N+M) O(N+M) Stable Bucket Sort O(N+M) O(N^2) O(N+M) O(N+M) Stable Radix Sort O(N*M) O(N*M) O(N*M) O(N+M) Stable Bubble SortHow to do it…Compare the adjacent elements. If the first element is greater than the second element, swap them. Loop until reaching the last pair of elements. Repeat until all the array is sorted. How to code it…123456789void BubbleSort(int array[]) { for (int i = 0; i &lt; array.length(); i++) { for (int j = 0; i &lt; array.length() - i; j++) { if (array[j] &gt; array[j+1]) { swap(array[j], array[j+1]); } } }} How to improve it…We can make a judgement before we do the algorithm. Check whether the array is already sorted or not. 1234567891011121314void BubbleSortwithCheck(int array[]) { for (int i = 0; i &lt; array.length(); i++) { bool sorted = true; for (int j = 0; j &lt; length() - i; j++) { if (array[j] &gt; array[j+1]) { swap(array[j], array[j+1]); sorted = false; } } if (sorted) { break; } }}","link":"/2020/04/22/2020-04-22-Sorting-Algorithms---Bubble-Sort/"},{"title":"Sorting Algorithms - Quick Sort","text":"In this series of blogs, we will talk about different sorting algorithms. All the algorithms in the table below will be covered. Algorithm Time Complexity (Average Case) Time Complexity (Worst Case) Time Complexity (Best Case) Merg Stability Bubble Sort O(N^2) O(N^2) O(N^2) O(1) Stable Quick Sort O(NlogN) O(N^2) O(NlogN) O(logN) Not Stable Quick Sort (with Random Selection) O(NlogN) O(NlogN) O(NlogN) O(logN) Not Stable Insertion Sort O(N^2) O(N^2) O(N) O(1) Stable Selection Sort O(N^2) O(N^2) O(N^2) O(1) Not Stable Heap Sort O(NlogN) O(NlogN) O(NlogN) O(1) Not Stable Merge Sort (with double divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Merge Sort (with multi divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Counting Sort O(N+M) O(N+M) O(N+M) O(N+M) Stable Bucket Sort O(N+M) O(N^2) O(N+M) O(N+M) Stable Radix Sort O(N*M) O(N*M) O(N*M) O(N+M) Stable Quick SortHow to do it…Divide and conquer. In each division, seperate the data into two parts. All elements in the first part should be all less than the elements in the second part. Loop until the array is sorted. How to code it…12345678910111213141516171819202122int partition(int array[], int left, int right) { int pivot; if (left &lt; right) { int low = left; int high = right; int key = array[left]; while (low &lt; high) { while (array[high] &gt;= ket &amp;&amp; low &lt; high) { high--; } array[low] = array[high]; while (array[low] &lt;= array[high] &amp;&amp; low &lt; high) { low++; } array[high] = array[low]; } pivot = low; array[pivot] = key; } return pivot;} 1234567void QuickSort(int array[], int left, int right) { if (left &lt; right) { int pivot = partition(array, left, right); QuickSort(array, left, pivot - 1); QuickSort(array, pivot + 1, right); }} How to improve it…12345678910void QuickSortRandom(int array[], int left, int right) { if (left &lt; right) { srand(unsigned(time(NULL))); int Tem = rand()%(right - left + 1) + left; swap(array[left], array[Tem]); int pivot = partition(array, left, right); QuickSortRandom(array, left, pivot - 1); QuickSortRandom(array, pivot + 1, right); }}","link":"/2020/04/23/2020-04-23-Sorting-Algorithms---Quick-Sort/"},{"title":"Insurance Management System - Overview","text":"In this series of blogs, we will talk about how to build a Insurance Management web application together with database system. BackgroundTom’s dad works in an insurance company. His work is to drop down who bought what kind of insurance, on which day does the customer receives an invoice, and on which day does the customer makes a payment. Oneday, Tom’s dad talks to Tom: “Oh Tom, you see see you, one day day, only eat, do nothing, build a management system for me.” Tom becomes not happy. Rlational ModelTom’s dad talks to Tom about what information is needed. After discussion, Tom draws the following relational model: Summary of development environmentTom thinks it over and over, finally decides to apply the following development environment: Programming language: Python3.5 Framework: Django2.1.1 Database: SQLite Code editor: Pycharm Application FeaturesTo build the application, Tom mainly used the ORM model characteristic provided by Django. With ORM, so that he can treat each table as a CLASS in python and each time he insert data into that table, he simply instantiate an object, together with Object-Oriented Programming, he can make queries, add items, change information and delete object in a convenient way. The features of the application are but not restricted to: Normal UsersFor users who are new to the application, he/she can register themselves in the REGISTER page. As shown below, the REGISTER page can be access by clicking the REGISTER button on the right of system bar. If information is filled not properly, application will generate warnings to helper users. When information filled in the correct way, user will be directed to the login page with notice of successful account creation. After logging in, application will go to welcome page, where the username of user is confirmed again to make sure the user is about to purchase insurance. As long as the user has been logged in, the username and email will always be displayed on each page. After confirmation, the user will be guided to the insurance purchase page, the first insurance is Home insurance, after which user is required to enter the information about home under insurance. When Home insurance purchase is finished, user is going to the Auto insurance purchase page, after which the information about vehicle under insurance needs to be provided, and finally the driver information is also needed. Notice the side bar, there are more detailed instruction about how to buy different kinds of insurance. If the user want to check detailed information about the insurances purchased, he/she can click on the PROFILE button. In the PROFILE window, user can update email address if needed. And for each insurance listed, to check the detail information, just click on the insurance number will work. When finish browsing, user can click on LOGOUT to logout the account. Super UserFor users with administration power, they can go to 127.0.0.1:8000/admin/ to access the administrative page. After logging in, Tom can manage all stored data, including add invoice and payment information for different users. (Notice that users pay their bill in other sites, this site is just designed for users to choose insurance and look for records.) Project OutcomeIn this project, Tom designed and built a web-based database application. There are three fields Tom have outcomes: web development database development connection between web development and database development For the web development, Tom chose to use python as programming language and django as web framework. This combination guaranteed us a good view of Object Oriented Programming experience. All the users and each recorded were created as an object from CLASS Tom defined. Django is a MVT like frame, therefore, during web development, it is important to get clear of which page Tom are working on, which html Tom want to return and which template is required by django. For database, Tom used the simple but powerful SQLite to perform its duty. Together with Pycharm, Tom can clearly see the structure of our project and database, in addition to manage through admin page, Tom can also open the SQLite database with Navicat or other database management software to easily manage our SQL. The connection between database and web application is established by the ORM character of django, Tom can use OOP procedure to create and manage different records. But Tom also need to be clear about the foreign key relationship between different tables, each time Tom create or delete a record, Tom need to guarantee its foreign key (if any) is assigned. This gives us a good taste of how database is used in reality. Tom is happy now.","link":"/2020/04/28/2020-04-28-Insurance-Management-System---Overview/"},{"title":"EMPLACE_BACK in C++","text":"There are different type of containers in C++ STL. To add a new element into the back of a container, we normally use push_back(). In this blog, we will look into a new way of performing push back - emplace_back(). Background KnowledgeRvalue References: with aim of increasing the efficiency of C++, rvalues are included. It doesn’t need to copy the value, the rvalue reference is bound to the value itself. To claim an Rvalue: 1T &amp;&amp; T_reference = t; For emplace_back( )…How is emplace_back() defined: 12template &lt;typename T&gt; void emplace_back (T &amp;&amp; t); An example for emplace_back() from this blog: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; struct President { std::string name; std::string country; int year; President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) { std::cout &lt;&lt; \"I am being constructed.\\n\"; } President(const President&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) { std::cout &lt;&lt; \"I am being copy constructed.\\n\"; } President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) { std::cout &lt;&lt; \"I am being moved.\\n\"; } President&amp; operator=(const President&amp; other); }; int main() { std::vector&lt;President&gt; elections; std::cout &lt;&lt; \"emplace_back:\\n\"; elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994); //没有类的创建 std::vector&lt;President&gt; reElections; std::cout &lt;&lt; \"\\npush_back:\\n\"; reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936)); std::cout &lt;&lt; \"\\nContents:\\n\"; for (President const&amp; president: elections) { std::cout &lt;&lt; president.name &lt;&lt; \" was elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; } for (President const&amp; president: reElections) { std::cout &lt;&lt; president.name &lt;&lt; \" was re-elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; } } The output from the above code would be: 123456789emplace_back:I am being constructed. push_back:I am being constructed.I am being moved. Contents:Nelson Mandela was elected president of South Africa in 1994.","link":"/2020/05/16/2020-05-16-emplace_back-in-C++/"},{"title":"SWAP Function","text":"In this blog, we will look into several ways of implementing swap in different ways. Intermedia Variable12345int a = 1;int b = 2;int tem = a;a = b;b = temp; Addition and Subtraction12345int a = 1;int b = 2;a = a+b;b = a-b;a = a-b; Multiplication and Division12345int a = 1;int b = 2;a = a*b;b = a/b;a = a/b; XOR12345int a = 1; int b = 2;a = a^b;b = b^a; // b = b^(a^b) = b^a^b = b^b^a = 0^a = aa = a^b; // a = (a^b)^a = a^b^a = a^a^b = 0^b = b","link":"/2020/05/17/2020-05-17-SWAP-Function/"},{"title":"知识点整理-1","text":"1. C++的内存管理分哪些区，分别有什么作用 C++的内存主要分为五大区：堆区、栈区、自由存储区、全局/静态存储区、常量存储区。 堆区：程序员分配释放，使用new分配内存块，使用delete归还内存空间。 栈区：编译器自动分配释放，用于存放局部变量、函数参数等。 自由存储区：程序员分配释放，使用malloc分配内存块，使用free归还内存空间。 全局区/静态区：全局变量和静态变量分配在同一块内存中。 常量存储区：存放不可修改的常量值。 2. C++源文本到可执行文件需要经历哪些阶段 预处理：将源代码和相关头文件处理成一个.i文件。 编译：将预处理的文件进行词法分析、语义分析，优化后产生相应的汇编代码。 汇编：将汇编语言代码翻译成目标机器码。 链接：把每个机器码文件按照要求连接起来，解决代码间的相互依赖问题。 3. 析构函数为什么必须是虚函数 为了保证整个派生类的对象完全被释放。 当析构函数不为虚函数时，在删除基类指针时，只会调用基类析构函数，而不调用派生类的析构函数，这样会导致基类指针指向的派生类对象析构不完全。 当析构函数为虚函数时，在删除基类指针时，会调用该指针指向派生类的析构函数，同时派生类的析构函数自动调用基类析构函数，保证对象被完全释放。 4. 虚函数和纯虚函数有什么区别 虚函数：在基类中存在定义，可以直接使用，也可以被派生类重写后使用。 纯虚函数：在基类中不存在定义，只有声明，必须在子类中定义后才能使用。 5. 虚函数的实现机制 编译器自动为存在虚函数的类生成一个虚函数表，当声明该类的对象时，放入一个隐式指针变量，指向虚函数表。 在调用方法时，系统根据不同对象的指针，寻找到对应的虚函数表，进而找到所需的函数地址进行调用。 6.野指针怎么出现的 指针变量未初始化。 指针释放后未置空。 返回指向栈内存的指针。 7. 类和结构体有什么区别 class中默认成员访问权限为private，而struct中为public。 class可以用于表示模板类型，sruct不行。 class是引用类型，struct是值类型。 class多用来存储数据量大、逻辑复杂的对象，struct多用来存储轻量级对象。 class多用于表现抽象和多级别的对象层次。 8. 什么情况会导致内存泄漏 程序循环new创建出来的对象没有及时delete掉。 delete掉一个void*类型的指针，导致没有调用到对象的析构函数。 new创建了一组对象，回收时未调用delete[]，而调用了delete，导致只有对象数组的第一个对象的析构函数得到执行并回收了内存。 9. 五种IO模型 阻塞IO：进程发起IO系统调用后，进程被阻塞，转到内核空间处理，处理完毕后返回进程。 非阻塞IO：进程发起IO系统调用后，如果内核缓冲区没有数据，返回给进程一个错误，而不会阻塞进程，如果缓冲区有数据，则将数据返回给进程。【发起IO后，内核便开始处理，一直有返回值，但是直到内核处理完才有数据。】 IO复用：多个进程的IO注册到一个复用器（select）上，select监听所有进来的IO。【同时负责很多水龙头，哪个水龙头要来水了，就打开哪一个。】 信号驱动IO：进程发起IO系统调用后，向内核注册信号处理函数，然后进程返回不阻塞，当内核数据就绪则通知进程发起IO调用读取数据。【首先用信号通知内核空间，等到数据就绪再发起IO。】 异步IO：进程发起IO系统调用后，进程返回不阻塞，等内核将IO处理完，通知进程数据结果。 10. TCP如何保证传输的可靠性 校验和：接收方和发送方均进行校验和的计算，并进行对比。 序列号：TCP传输时将每个字节的数据都进行编号。 确认应答：TCP传输过程中，每次接收方收到数据后，均对传输方进行确认应答（ACK）。 超时重传：发送方在发送完数据后进行等待，一段时间后没有收到ACK，则对刚才的数据进行重新发送。 连接管理：三次握手与四次挥手。 流量控制：在回复ACK时，接收端介绍自己接受数据的缓冲区剩余大小。 拥塞控制：慢开始、拥塞避免等操作。 11. TCP快速重传的实现 举例：发送方发出1、2、3、4、5五份数据，1送到了，则回复ACK2，但是2没送到，3送到了，于是继续回复ACK2，后面4和5都送到了，继续回复ACK2，直到发送端收到三次ACK2，则重新发送2，然后接收端收到2，因为3、4、5都已经收到，所以回复ACK6。","link":"/2020/04/15/2020-04-15-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-1/"},{"title":"知识点整理-4","text":"1. 黑盒测试和白盒测试 黑盒测试：即功能性测试 等价类划分：有效等价类即对于程序的规格来说是合理的、有意义的；无效等价类即对程序的规格来说是不合理的、每有意义的。 边界值分析：对各种边界情况设计测试用例。 因果图法：根据输入的各种组合来设计测试用例，用于检查程序输入条件的各种组合情况。 场景法：通过对正常场景和中断操作的场景进行实验来完成测试。 白盒测试：即结构测试或逻辑驱动测试 静态测试：代码检查、结构分析、文档测试等。 动态测试：功能确认、接口测试、性能分析等。 2. 单元测试、集成测试和系统 单元测试：对函数、类的某一个方法等基本单元进行正确性检验的测试。 集成测试：对组装好的模块进行功能性验证的测试。 系统测试：对继承好的软件作为计算机系统的一部分与外围设备或支持性软件一起进行的实际测试。 3. 如何设计测试用例 利用1.中方法进行分析设计，需要包含用例编号、用例标题、功能模块名称、前置条件、输入数据、操作步骤、预期结果、优先级、执行结果、编写人、执行人、其他补充。 4. 如何测试微信的点赞功能 功能测试 点赞朋友圈，是否成功。 取消点赞，是否成功。 多次点赞，有何结果。 多人点赞，以何顺序呈现。 接口测试 被点赞人能否收到消息。 点赞人能否收到后续消息。 性能测试 点赞后，结果显示时间是否符合规范。 兼容测试 在安卓、ios上点赞，结构是否有差异。 可用性测试 网络连接不稳定时，点赞的结果。","link":"/2020/04/19/2020-04-19-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-4/"},{"title":"知识点整理-5","text":"1. MySQL查询10-20条的数据 1select * from table limit 10, 20 2. 查找二叉树最大深度 1234567891011121314151617181920struct TreeNode { int val; TreeNode * left; TreeNode * right; TreeNode(int x) : val(x), left(NULL), right(NULL){}};int dfs (TreeNode * root, int result) { if (!root) { return result; } int left_res = dfs(root-&gt;left, result + 1); int right_res = dfs(root-&gt;right, result + 1); return max(left_res, right_res);}int MaxDepth(TreeNode * root) { int result = 0; return dfs(root, result);} 3. 判断IP地址是否合法 12345using namespace boost::xpressive; bool CheckIP(char *ip) { cregex expression = cregex::compile(\"(25[0-4]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])[.](25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])[.](25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])[.](25[0-4]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])\"); return regex_match(ip, expression); } 4. udp如何实现可靠连接 在应用层参照TCP实现超时重传、有序接受、应答确认、滑动窗口、流量控制等功能。 现已实现的程序有RUDP、RTP、UDT。 5.MySQL 查询以135开头的手机号 1select * from test where shouji like '135%';","link":"/2020/04/20/2020-04-19-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-5/"},{"title":"知识点整理-3","text":"1. 计算机网络分层模型 7层 (osi国际标准组织定制)： 应用层：为程序提供网络服务。 表示层：数据格式化，加密、解密。 会话层：建立、维护、管理会话链接。 传输层：建立、维护、管理端到端链接。 网络层：IP寻址和路由选择。 数据链路层：控制网络层与物理层之间的通信。 物理层：比特流传输。 四层 (TCP/IP)： 应用层：ping、DNS、telnet 传输层：UDP、TCP 网络层：ICMP、IP 数据链路层：ARP、DataLink、RARP 2. HTTP请求包含哪几个部分 请求行： 请求方法：HTTP最常见的请求方法为GET和POST。 请求URL：请求对应的URL地址。 HTTP协议及版本：协议名称及版本号。 请求头： 包含多个属性，格式为“属性名：属性值”，服务器根据请求头来获取客户端的信息。 请求体： 将一个页面表单中的组件值通过param1=value &amp; param2=value2的键值对形式编码成一个格式化串，承载多个请求参数的数据。 3. TCP拥塞控制 主要为四个算法： 慢开始：在TCP链接刚建立时，一点一点地增大拥塞窗口cwnd，慢慢变为指数增长，试探网络的承受能力，直到cwnd大于等于ssthresh（slow start threshold）则进入拥塞避免。 拥塞避免：收到一个ACK，即每经过一个往返时间RTT，就把发送方的cwnd加1，使其按线性规律缓慢增长。 乘法减小【TCP Tahoe】：不论在慢开始阶段还是拥塞避免阶段，只要出现超时，即可能发生了阻塞，发生丢包，就把慢开始门限ssthresh的值减半，即设置为当前cwnd的一半，并开始执行慢开始算法。 快速重传【TCP Reno】：发生丢包时，把cwnd设置为当前的一半，ssthresh设置为缩小后的cwnd大小，进入快速恢复算法。 快速恢复【TCP Reno】：设置cwnd=cwnd+3MSS（因为收到3个重复的ACK，所以加三个MSS），重传DACKs指定的数据包，如果再收到DACKs，则cwnd增加1，若收到新的ACK，表明重传包成功，退出快速恢复，将cwnd设置为ssthresh，进入*拥塞避免**算法。 4. 死锁与死锁的处理 形成死锁的四个必要条件： 互斥：在某段时间内某资源只由一个进程占用。 持有并等待：某进程已经持有一个或多个资源，但是还需请求其他资源，而它请求的资源不能立即获得，需要等待。 不可抢占：进程已经获取的资源在使用过程中不能被其他进程抢占，只能在使用完后，由该进程自己释放。 环路等待：形成进程和请求资源之间的环路。 死锁的预防： 互斥：不易预防 占有并等待：方法一：不持有并等待，如果一个进程一次请求获取不了所有资源，那么它不可占用任何资源，即释放掉它已经占有的资源；方法二：持有不等待，保证资源充足，只要请求资源，就分配给资源。 不可抢占：如果一个进程所请求的资源被另一进程占有，使它可以抢占另一进程占有的资源。 环路等待：对资源进行排序，每个进程按照固定的顺序访问资源。 死锁的避免： 资源请求图算法：利用资源分配图，引入需求边表示进程可能在将来某个时候申请资源，只有申请边变为分配边而不会导致资源分配图形成环时，才允许申请。 银行家算法：当新进程进入系统，系统对其所需资源的最大数量进行统计，若超过当前资源综合，则该进程必须等待直到其他进程释放资源。 5. 什么是关系型数据库 关系型数据库建立在关系型数据模型的基础上，借助于集合、代数等数学概念和方法来处理数据的数据库。 6. KV存储 举例：Redis、MongoDB 不经常更新的、重要的数据一般使用关系数据库存储。 数据结构简单、有分布式数据存储的需求使用KV数据库。 7. 非递归前中后序遍历二叉树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566struct TreeNode { int val; TreeNode * left; TreeNode * right;};void PreOrder (TreeNode * root) { stack&lt;TreeNode *&gt;s; TreeNode * ptr = root; while (ptr != nullptr || !s.empty()) { if (ptr != nullptr) { cout &lt;&lt; ptr-&gt;val &lt;&lt; endl; s.push(ptr); ptr = ptr-&gt;left; } else { ptr = s.top(); s.pop(); ptr = ptr-&gt;right; } }}void InOrder (TreeNode * root) { stack&lt;TreeNode *&gt; s; TreeNode * ptr = root; while (ptr != nullptr || !s.empty()) { if (ptr != nullptr) { s.push(ptr); ptr = ptr-&gt;left; } else { ptr = s.top(); cout &lt;&lt; ptr-&gt;val &lt;&lt; endl; s.pop(); ptr = ptr-&gt;right; } }}void PostOrder (TreeNode * root) { stack&lt;TreeNode *&gt; s; TreeNode * ptr = root; TreeNode * TemNode = nullptr; while (ptr != nullptr || !s.empty()) { if (ptr != nullptr { s.push(ptr); ptr = ptr-&gt;left; } else { ptr = s.top(); if (ptr-&gt;right != nullptr &amp;&amp; ptr-&gt;right !- TemNode){ ptr = ptr-&gt;right; } else { cout &lt;&lt; ptr-&gt;val &lt;&lt; endl; s.pop(); TemNode = ptr; ptr = nullptr; } } }} 8. 如何实现一个栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class QueueStack {private: queue&lt;int&gt; first; queue&lt;int&gt; second; public: bool empty() { if (first.empty() &amp;&amp; second.empty()){ return true; } else { return false; } } int top() { if (first.empty()){ return second.front(); } else { return first.front(); } } void pop() { if (first.empty()) { second.pop(); } else { first.pop(); } } void push (int x){ if (frist.empty()){ first.push(x); while (!second.empty()) { first.push(second.front()); second.pop(); } } else { second.push(x); while(!first.empty()) { second.push(first.front()); first.pop(); } } }} 9. HTTP状态码 1xx：收到请求，需要请求者继续操作。 100：继续。 101：切换协议。 2xx：操作被成功接收并处理。 200：请求成功。 201：已创建。 202：已接受。 203：非授权信息。请求成功。 204：无内容。 205：重置内容。 206：部分内容。 3xx：重定向，需要进一步操作以完成请求。 300：多种选择。 301：永久移动。 302：临时移动。 303：查看其他地址。 304：未修改。 305：使用代理。 307：临时重定向。 4xx：客户端错误，请求包含语法错误或无法完成请求。 400：Bad Request。 401：Unauthorized。 403：服务器理解客户端的请求，但是拒绝执行。 404：无法根据请求找到资源。 405：客户端请求中的方法被禁止。 406：Not Acceptable。 407：Proxy Authentication Required。 408：Request Timeout。 409：服务器处理请求时发生了冲突。 410：客户端请求的资源已经不存在。 411：Length Required。 412：Precondition Failed。 413：Request Entity Too Large。 414：Request URI Too Large。 415：Unsupported Media Type。 416：客户端请求的范围无效。 417：Expectation Failed。 5xx：服务器错误，服务器在处理请求的过程中发生了错误。 500：服务器内部错误，无法完成请求。 501：服务器不支持请求的功能。 502：Bad Gateway。 503：Service Unavailable。 504：Gateway Timeout。 505：HTTP version not supported。","link":"/2020/04/17/2020-04-17-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-3/"},{"title":"知识点整理-2","text":"1. 两个有序链表合并成一个(leetcode 21) 12345678910111213141516171819202122struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {}};ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1 == NULL){ return l2; } if (l2 == NULL){ return l1; } if (l1-&gt;val &lt; l2-&gt;val){ l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } else { l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; }} 2. GET和POST的区别 GET所发送的数据是URL的一部分，POST数据不会显示在URL中。 GET和POST方法没有本质区别，只是报文格式不同，两者都使用HTTP，都是不安全的，想要安全传输需要使用HTTPS。 3. HTTPS的实现原理 HTTPS原理：在传输层（TCP）和应用层（HTTP）之间加了一层SSL/TLS。 具体加密过程：1. 服务器端发送公钥证书；2. 客户端检验证书是否有效，是，则生成一个随机密钥，并用服务端的公钥进行加密后发送；3. 服务器端用自己私钥加密，取出客户端的随机密钥，将需要发送的内容用该密钥加密并发送。 4. Linux查看最近的日志用什么指令 tail： tail -f test.log head： cat test.log | tail -n +3000 | head -n 1000 cat： cat filename tac：把cat的内容反写过来 tac filename echo： echo “the echo command test!” 5. hash冲突解决 开放地址法：再散列函数： Hi = (H(key) + di) % m, i = 1, 2, …, n 不同di值对应不同散列方法。 再哈希法：同时构造多个不同的哈希函数，某一个发生冲突时计算下一个，直到冲突不再产生。 链地址法：将所有哈希地址为i的元素构成一个单链表。 建立公共溢出区：将哈希表分为基本表和溢出表，和基本表发生冲突的元素填入溢出表。 6. 快排的时间复杂度和空间复杂度 平均情况下快速排序的时间复杂度是O(nlgn)，最坏情况是n的平方，可通过随机算法避免最坏情况，或者可先求序列的中值，然后选取中值作为主元素。 由于递归调用，快排的空间复杂度是O(lgn)。 7. 堆排序的时间复杂度和空间复杂度 第一次建堆时间复杂度：O(n)。 更改元素时建堆时间复杂度：O(nlgn)。 堆排序平均时间复杂度：O(nlgn)。 空间复杂度：O(1)。 8. B树和B+树的定义 B树中每个节点的关键字都有data域。 B+树除了叶子节点，其他节点只有索引。 9. C++ vector里size和capacity的区别 size是当前vector容器的真实占用大小。 capacity是当前允许的最大元素数。","link":"/2020/04/16/2020-04-16-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-2/"},{"title":"知识点整理-6","text":"1. Linux和端口号、进程、文件相关的命令 静态进程查看: ps 例：通过进程名查看进程号 1ps ax | fgrep [进程名] 网络查看: netstat 例：通过进程号查看进程正在监听的端口 1netstat -antp | fgrep [进程号] 例：查看端口是否正在监听 1netstat -antp | grep [端口号] 搜索指定文件内容: grep (global regular expression print) 例：搜索as在123.txt中的行号位置 1grep -n as 123.txt 2. 查找二叉树最大深度 1234567891011121314151617181920struct TreeNode { int val; TreeNode * left; TreeNode * right; TreeNode(int x) : val(x), left(NULL), right(NULL){}};int dfs (TreeNode * root, int result) { if (!root) { return result; } int left_res = dfs(root-&gt;left, result + 1); int right_res = dfs(root-&gt;right, result + 1); return max(left_res, right_res);}int MaxDepth(TreeNode * root) { int result = 0; return dfs(root, result);} 3. 判断IP地址是否合法 12345using namespace boost::xpressive; bool CheckIP(char *ip) { cregex expression = cregex::compile(\"(25[0-4]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])[.](25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])[.](25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])[.](25[0-4]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])\"); return regex_match(ip, expression); } 4. udp如何实现可靠连接 在应用层参照TCP实现超时重传、有序接受、应答确认、滑动窗口、流量控制等功能。 现已实现的程序有RUDP、RTP、UDT。 5.MySQL 查询以135开头的手机号 1select * from test where shouji like '135%';","link":"/2020/07/23/2020-07-23-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-6/"},{"title":"计算机网络知识点总结","text":"1. Https加密过程 客户端发起握手请求； 服务端返回已有的证书公钥（服务端通过CA认证后，拥有证书公钥和证书私钥）； 客户端验证证书是否有效； 若证书有效，则生成一个随机数； 用证书公钥加密生成的随机数； 将加密后的密钥发送给服务端； 服务端用证书私钥解密密钥； 服务端使用解密出的密钥加密要发送的内容并发送给客户端； 客户端使用秘钥解密信息。 2. 对称加密与非对称加密 对称加密：加密和解密使用同一个密钥； 非对称加密：使用公钥和私钥进行加解密。 3. CLOSE_WAIT和TIME_WAIT 在四次挥手中， CLOSE_WAIT：服务端收到FIN后，发送ACK给客户端，之后进入CLOSE_WAIT状态； TIME_WAIT：客户端收到FIN后，发送ACK给服务端，之后进入TIME_WAIT状态。 4. TCP如何保证传输可靠性 数据包校验； 重排序：TCP将失序数据进行重新排序后才交给应用层； 应答机制：回复ACK； 超时重传； 流量控制：TCP连接的每一方都有固定大小缓冲空间，通过可变大小的滑窗协议完成。 5.如何预防TCP的DDos攻击 限制同时打开SYN半链接的数目； 方法：在注册表中对TCPMaxHalfOpen相关参数进行调整； TCPMaxHalfOpen相关参数： SynAttackProtect：决定了系统受到SYN攻击时采取的保护措施，包括减少系统SYN+ACK的重试次数等； TcpMaxHalfOpen：系统允许同时打开的半链接值； TcpMaxHalfOpenRetried：决定在什么情况下系统打开SYN攻击保护； 缩短SYN半链接的Time out时间。 6. TCP如何实现拥塞控制 慢启动：以指数方式，由小到大逐渐增加拥塞窗口(cwnd)的大小，慢启动达到ssthresh阈值则进入拥塞避免； 拥塞避免：每经过一个往返时间RTT就把发送方拥塞窗口增加1，按照线性增长，发生拥塞，cwnd降为1，重新慢启动； 快重传：接收方收到失序报文后，立即发出重复确认，发送方收到三个连续重复确认则立即重传； 快恢复：发送方收到重复确认后，执行乘法减小 ，把ssthresh减半，但不执行慢开始，因为如果发生阻塞，不会收到多个重复确认，而是将cwnd设置为ssthresh大小进行拥塞避免。 7. 从输入网址到获得页面的过程 浏览器通过DNS查询对应IP地址： 浏览器搜索自身DNS缓存； 搜索操作系统DNS缓存； 向本地DNS服务器进行查询； 若不在本地域名服务器，则递归或迭代查询： 递归查询：服务器作为DNS客户向根服务器查询； 迭代查询：根服务器告知服务器需要查询的IP，服务器自己进行查询； 获取IP地址后，浏览器向服务器请求建立连接，发起三次握手； TCP连接建立后，浏览器向服务器发送HTTP请求； 浏览器对请求进行处理，并将处理结果返回给浏览器； 浏览器进行渲染，呈现页面给用户。 8. Session 与 Cookie Session： 用户访问服务器时，服务器首先检查请求中是否包含sessionId，若包含，说明session已创建，若不包含，则为用户建立一个session并分配sessionId（依赖Cookie）； 用户提交表单时，浏览器将用户的SessionId附在HTTP头信息中，服务器处理完表单将结果返回sessionId对应的用户； 若Cookie被禁用： URL重写：直接将sessionId附在URL后； 表单隐藏字段：修改表单，添加一个隐藏字段，以便提交时能够回传sessionId session共享：修改cookie的域名为父域名； 使用场景：购物车； Cookie： 若服务器需要记录用户状态，则使用response向客户端颁发一个cookie，再次请求时，浏览器将请求网址连同cookie一起提交给服务器； 会话Cookie和持久Cookie： 会话cookie：不设置过期时间，关闭浏览器窗口，cookie就消失，一般保存在内存里而不是硬盘上； 持久cookie：设置了过期时间，cookie有效指导超过了设定的过期时间，一般存储在硬盘上； 使用场景：登录网站。 9. 七层网络体系结构 物理层：实现相邻计算机节点之间比特流透明传送； 数据链路层：接手物理层的位流行驶数据，封装成帧，传送到上一层，同样，也将上一层的数据帧，拆装成位流转发到物理层； 网络层：将网络地址翻译为对应的物理地址，并通过路由算法选择最佳路径； 传输层：为不同主机上运行的进程提供逻辑通信； 区别于网络层：网络层完成主机间的逻辑通信，传输层完成应用进程间的逻辑通信； 会话层：应用程序与网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信； 表示层：对来自应用层的命令和数据进行解释； 应用层：为用户的应用进程提供网络通信服务。 10. TCP和UDP对应的常见应用层协议 TCP： FTP：文件传输协议； Telnet：用于远程登录的端口： 和ssh的区别： telnet为明文传送，ssh为加密传送； ssh使用公钥对服务器的用户进行身份验证，telnet没有使用公钥； SMTP：邮件传送协议，用于发送邮件； POP3：用于接收邮件； HTTP； UDP： DNS：域名解析服务； SNMP：网络管理协议，用于管理网络设备； TFTP：简单文件传输协议。 11. ARP 将IP地址转换为MAC地址； 网络通过帧进行传输，帧里面需要目标主机的MAC地址。 12. 常见状态码 1XX：请求已被接受，正在处理； 2XX：请求成功被处理； 3XX：重定向： ​ 301：永久性转移； ​ 302：暂时性转移； ​ 304：已缓存； 4XX：客户端请求不合法： ​ 400：请求语法有问题； ​ 403：拒绝请求； ​ 404：客户端所访问的页面不存在； 5XX：服务器不能处理合法请求： ​ 500：服务器内部错误； ​ 503：服务暂时不可用。","link":"/2020/08/31/2020-08-31-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"操作系统知识点总结","text":"1. 进程和线程 进程：系统进行资源分配的基本单位； 线程：CPU调度的基本单位： 共享进程的全部资源； 独有程序计数器、寄存器和栈。 2. 进程通信 低级通信：用信号量进行的进程间的互斥和同步； 高级通信：利用操作系统所提供的一组通信命令传送大量数据的通信方式： 共享存储器系统：例：剪贴板； 消息传递系统：例：邮槽； 管道通信系统； 通信方式： 管道： 有名管道：单向通信，有固定的读端和写端，半双工通信方式，允许无亲缘关系进程间的通信； 无名管道：数据单向流动，只能在具有亲缘关系的进程间使用； 信号量：是一个计数器，控制多进程对共享资源的访问，作为一种锁机制； 消息队列：消息的链表； 信号； 共享内存：最快的IPC，常与信号量配合，实现进程间的同步和通信； 套接字。 3. 线程通信 互斥量； 信号量； 信号。 4. 死锁 概念：在多个并发进程中，某个进程持有某种资源而又等待别的进程释放他们保持的资源，在为改变状态之前不能向前推进，从而在这一组进程中产生了死锁，多个进程被无限期地阻塞、相互等待的状态； 必要条件： 互斥：一个资源每次只能被一个进程使用； 不可抢占：进程已获得的资源，在未使用完之前，不能前行剥夺； 占有并等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放； 环形等待：若干进程之间形成一种首尾相接的循环等待资源关系； 死锁的解除与预防： 破坏互斥： 允许系统资源都能共享； 缺点：有些资源不能同时访问，如打印机，且在某些场合应保护互斥性； 破坏占有并等待： 预先静态分配，在进程运行前一次申请完它所需要的全部资源，在它的资源未满足前，不投入运行，一旦投入运行资源全部归他所有； 缺点：系统资源浪费，个别资源长期被占用，导致一些进程不能运行； 破坏不可抢占： 当一个进程保持了某些资源，请求新资源而不能被满足时，必须释放所保持的资源，以后重新申请； 缺点：实现复杂，释放资源可能会造成前一阶段工作失效，常用于易于保存和回恢复的资源； 破坏循环等待： 给系统资源编号，规定进程必须按照编号递增的顺序请求资源； 缺点：实现复杂，编号不一定与实际使用顺序相同； 避免死锁的方式： 判断系统状态：在分配前，先计算分配的安全性； 银行家算法： 申请的贷款额度不能超过银行西安有资金总额； 分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额； 暂时不能满足客户申请的资金额度时，在有限时间内给予贷款； 客户要在规定时间内还款。 5. 分段与分页内存管理的区别 分段：符合用户视角，将地址空间分为若干段：代码段、数据段、堆、栈； 分页：方便系统管理，将逻辑地址划分为固定大小的页，物理内存划分为同样大小的帧，方便程序加载。 6. 虚拟内存 让每个进程拥有独立的地址空间，且这些空间被分为大小相等的页，被映射到物理内存中，对进程而言，逻辑上有很大的内存空间，但其中一部分对应于物理内存，还有一些在硬盘上； 页面置换算法：FIFO、LRU、LFU、OPT； 优点： 物理内存可为多个进程共享； 通过共享页允许进程间共享内存 虚拟内存大小： 对于32位：0-2^32 ~= 0-4G； 对于64位：0-2^64；","link":"/2020/08/31/2020-08-31-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"数据库知识点总结","text":"1. 数据库范式 第一范式：列不可分； 第二范式：有主键，保证完全依赖于主键； 第三范式：无传递依赖。 2. 索引 索引：对数据库表中一个或多个列的值进行排序的数据结构，从而达到快速查询、更新数据库表数据的目的； 实现：通常使用B树或B+树，如用B树可以实现O(logn)的时间复杂度检索： B树特点（m叉树）： 树中每个节点最多有m个子节点； 所有叶子节点都在同一层； B+树特点（InnoDB的索引实现）： 所有叶子节点中包含了所有关键码信息，及指向关键码记录的指针； 叶子节点本身根据关键码大小自小而大顺序链接； 含有两个指针，一个指向根节点，一个指向关键字最小的叶子节点； B+树更适合文件和数据库索引的原因： B+树内部节点相对B树更小，磁盘读写代价更低； 每次查找都需要从根节点到叶子节点，查询效率更稳定； 索引的优点： 加快数据检索速度； 加快表与表之间的连接； 减少分组和排序语句的时间； 通过创建唯一性索引，保证数据库中每一行数据的唯一性； 设置了索引但是无法使用的情况： 模糊查询，以“%”开头的Like语句； OR语句前后没有同时使用索引； 数据类型出现隐式转化，如varchar不加单引号自动转为int； 对于多列索引，必须满足最左匹配原则： 如对于索引(a, b, c)，生效情况为a、(a, b)、(a, b, c)； 因为针对联合索引构建的B+树优先保证最左元素有序； 什么字段适合创建索引： 经常作为查询选择的字段； 经常作为表连接的字段； 经常出现在order by、group by、distinct后面的字段； 创建索引时需要注意： 非空字段：需要使用0或特殊值代替NULL，否则会使索引运算更加复杂； 索引字段越小越好：数据库存储以页为单位，一页存储的数据越多，一次IO获取数据的效率越高； 索引缺点： 时间：创建、维护索引需要耗费时间，对表中数据进行增加、删除、修改时，索引也要动态修改，降低了数据的维护速度； 空间：索引需要额外的存储空间； 索引的分类： 普通索引和唯一性索引：索引列值的唯一性； 单个索引和复合索引：索引列包含的列数； 聚簇索引和非聚簇索引： 聚簇索引：按照每张表的主键构建一个B+树，InnoDB中表数据文件本身就是按照B+树组织的索引结构； 非聚簇索引：按照value进行检索，最后获得想要数据的主键，再通过主索引进行检索； 唯一索引与主键索引： 主键索引：为主键创建的唯一索引； 唯一索引：索引列的值必须唯一，但允许有空值。 3. 数据库事务 事务的特性： 原子性（Atomicity）：事务所包含的一系列语句，要么全部成功执行，要么全部回滚； 一致性（Consistency）：事务的执行结果必须使数据库从一个一致性状态到领一个一致性状态； 隔离性（Isolation）：并发执行的并发之间不能相互影响； 持久性（Durability）：事务一旦提交，对数库中的数据改变是永久性的； 事务并发带来的问题： 脏读：一个事务读取了另一个事务未提交的数据； 不可重复读：同样条件下，两次读取结果不同，即，被读取的数据可以被其他事务修改； 幻读：同样条件下，两次读出的记录数不一样，即，被读取的数据可以被其他事务新增或删除； 隔离级别： 读未提交（Read Uncommitted）：允许一个事务读取另一个事务还没提交的数据，可能会提高性能，但是会导致脏读； 读已提交（Read Committed）：只允许读到其他事物已经提交的数据，不能避免不可重复读； 可重复读（Repeatable Read）：一个事务开启后，其他事务对于数据库的修改在本事务中不可见，直到本事务提交或回滚，但是，其他事物的删除新增可见，不能避免幻读的问题； 串行化（Serializable）：只允许事务串行执行； MySQL默认隔离级别是Repeatable Read。 4. MySQL的优化 SQL语句及索引的优化： SQL语句的优化： 通过慢查询日志，找出IO大的SQL、未命中索引的SQL，从而进行优化； 通过explain了解MySQL对于语句的处理，若扩展列extra出现Using filesort和Using temporay表示SQL需要优化； 其他tips： 优化insert语句：一次插入多值； 避免在where子句中使用!=或&lt;&gt;，以及避免在where子句中对字段进行null值判断，否则引擎会放弃使用索引而进行全表扫描； 优化嵌套查询：使用join代替子查询； 考虑用exists代替in； 索引优化： 在经常做查询选择的字段、表连接的字段、经常出现在order by/group by/distincy后的字段中建立索引； 避免索引失效； 表结构的优化： 选择合适的数据类型： 尽量选择较小的数据类型； 尽量使用简单的数据类型，int比varchar容易处理； 尽可能使用非空定义字段； 尽量避免使用text类型，非用不可需考虑分表； 表的范式优化； 垂直拆分和水平拆分： 垂直拆分：将表按照业务分类，分不到不同的数据库上，将数据压力分担到不同库上面； 水平拆分：将同一张表中的数据拆分到不同数据库中进行存储，或者把一张表拆分成多张小表； 5. drop、delete和truncate区别 delete： 用来删除表的全部或一部分数据行； 需要提交或回滚来执行或撤销删除操作； truncate： 删除表中所有数据； 不可回滚； 比delete更快，占用空间更小； drop： 删除表、所有数据行、索引等； 不可回滚； 总结：不需要一张表的时候，用drop；想删除部分数据行时，用delete；保留表结构但删除所有数据时，用truncate。 6. 悲观锁与乐观锁 悲观锁： 先获取锁在进行业务操作； 通过select … for update来实现，在当前事务结束时自动释放； MySQL中使用2.时所有扫描过的行都会上锁，需要确认使用了索引而不是全表扫描； 乐观锁： 先进行业务操作，最后更新时检查是否被更新，若未被更新，则更新成功，否则失败重试； 依靠逻辑实现； 在业务操作前获取需要锁的数据的版本号，更新时进行对比； 应用场景： 读多写少适合乐观锁； 读少写多适合悲观锁。 7. MySQL中MyISAM和InnoDB的差异 存储结构： MyISAM存储为：.frm文件存储表定义、.MYD数据文件、.MYI索引文件； InnoDB都保存在同一个数据文件中； 存储空间： MyISAM可被压缩，占据的存储空间较小； InnoDB需要更多内存和存储，会在主内存中建立专用的缓冲池，用于高速缓冲数据和索引； 事务支持： MyISAM每次查询具有原子性，执行速度比InnoDB更快，但是不支持事务； InnoDB支持事务、外键，具有事务提交、回滚等能力； 表锁差异： MyISAM只支持表级锁，CRUD时会自动给表加锁； InnoDB支持行级锁，在where主键时生效，非主键锁全表。","link":"/2020/09/01/2020-09-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"C++知识点总结","text":"1. 虚函数和纯虚函数 虚函数：为了动态绑定，允许被子类重新定义的成员函数， virtual returnType func(parameter); 纯虚函数：为了派生接口，virtual returnType func(parameter) = 0; 基类需要虚析构函数的原因：防止内存泄漏，假如没有虚析构函数，释放一个由基类指向派生类的对象是，不触发动态绑定，则只会调用基类析构函数，而不会调用派生类的，从而导致派生类内存空间的不到释放。 2. static和const关键字 static：存储在静态存储区，未初始化时自动初始化为0： 局部变量： 变为静态局部变量； 作用域仍为局部作用域； 离开作用域仍驻留在内存中，但不可访问； 全局变量： 变为全局静态变量； 在声明的文件之外不可见； 成员变量： 变为类的全局变量，被类的对象共享，包括派生类的对象； 必须在类外进行初始化，如int base::var = 10;，但可以用const修饰static数据成员，从而在类内初始化； 成员函数： 使得成员函数为所有对象共享，不含this指针； 可以独立访问，不需要创建实例，如base::func(3, 5); 不可直接引用类的非静态成员，但是可以引用静态成员； 不可同时用const和static修饰成员函数（const含this指针，static不含，冲突）； const： 表明变量不可修改； 限定成员函数不可修改任何数据成员； const与指针： const char *p：指向的内容不能改变； char * const p：将p声明为常指针，地址不能变，但是内容可变。 3. C++的内存分区 栈区（stack）：主要存放函数参数以及局部变量，由系统自动分配释放； 堆区（heap）：用户通过malloc/new手动申请释放，分配类似链表； 全局/静态区：存放全局变量、静态变量； 字符串常量区：字符串常量； 代码区：程序的二进制代码。 4. STL容器 底层数据结构： vector：数组； map、multimap：红黑树； unordered_map、unordered_nultimap：哈希表。 5. 内存泄漏 一般为堆内存泄漏，即程序在运行中动态申请的内存空间不使用后，未及时释放； 解决： 良好编程习惯； 重载new和delete，以链表形式自动管理分配的内存； 使用智能指针。 6. 32位、64位系统中，常用内置数据类型所占字节数 32位： char：1字节； 指针变量：4字节； short int：2字节； int：4字节； unsigned int：4字节； float：4字节； double：8字节； long：4字节； unsigned long：4字节； long long：8字节； 64位： char：1字节； 指针变量：8字节； short int：2字节； int：4字节； unsigned int：4字节； float：4字节； double：8字节； long：8字节； unsigned long：8字节； long long：8字节。 7. inline、volatile关键字 inline：解决频繁调用小函数大量消耗栈空间的问题； volatile：表明类型变量可悲更改，不再优化，需要从如内存中重新读取。 8. 深拷贝与浅拷贝 拷贝函数使用场景： 一个对象以值的方式传入函数体； 一个对象以值的方式从函数返回； 一个对象需通过另一个对象进行初始化； 区别： 浅拷贝：只是增加一个指针指向已存在的内存地址； 深拷贝：增加一个指针，并且申请一个新的内存用于存放复制的对象。 9. 派生类构造/析构函数调用顺序 构造函数：先基后派； 析构函数：先派后基。 10. 数据成员初始化顺序 顺序： 基类的静态变量或全局变量； 派生类的静态变量或全局变量； 基类的成员变量； 派生类的成员变量。 11. static_cast, dynamic_cast, const_cast, reinpreter_cast区别 static_cast与dynamic_cast： 发生时间不同，一个是static编译时，一个是runtime运行时； static_cast为强制类型转换，不提供运行时的检查； dynamic_cast用于转换指针和引用，不可用于转换对象，主要用于类层次间的上行和下行转换： 上行转换：B继承自A，由B转换为A； 下行转换：B继承自A，A转换为B； 上行转换时，static_cast和dynamic_cast效果相同，下行转换时，dynamic_cast具有类型检查，更安全。 12. 定义一个空类 编译器会做什么 当用到相关函数时，编译器会去自动生成：默认构造函数、默认拷贝构造函数、默认拷贝赋值操作符、默认析构函数； 所有自动生成的函数都是inline和public的。 13. 哪些函数不能成为虚函数 构造函数：假如子类继承基类构造函数，则子类对象将使用基类构造函数构造，而积累的构造函数并不知道自类的成员，不符合语义，且，多态是通过基类指针指向子类对象实现多态的，在对象构造之前，并没有对象产生，因此无法使用多态特性，是矛盾的； 内联成员函数：内联函数在编译时展开，而虚函数是在运行时绑定的，两者相违背； 静态成员函数：在编译时确定，无法动态绑定，不支持多态。 14. 内联函数与宏定义的区别 宏定义在于处理时把所有宏名用宏体替换，内联函数在编译时进行代码插入、展开、省去调用的开销； 宏定义没有类型检查，内联函数满足函数的性质，如有返回值、参数列表等。","link":"/2020/09/01/2020-09-01-C++%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"LeetCode题目总结-Array","text":"题目31:下一个排列 描述： 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路： 突破点：下一个更大排列的特性是什么。 步骤（以[5,6,11,9,7,5,3,1]举例）： 从尾部查找，直到找到当前元素大于前一元素，记录所在位置； 例：[5,6,11,9,7,5,3,1]，找到11大于6，记录位置2； 从1.中的位置到数组尾部的子序列中，找到一个比前一位置的大且相差最小的数； 例：[5,6,11,9,7,5,3,1]，在[11,9,7,5,3,1]找到7，7是比6大且最接近6的，从尾部开始遍历，遍历到大于6的索引即可； 交换2.中找到的数以及1.中确定的前一位置的数； 例：[5,6,11,9,7,5,3,1]，交换后变为[5,7,11,9,6,5,3,1]； 将该位置到数组尾部的子序列进行升序排列，因为已经为降序（1.中确定的位置为首次部位降序的位置），所以首尾两两交换即可； 例：[5,7,11,9,6,5,3,1],交换后为[5,7,1,3,5,6,9,11]； 另外，对于最大的排列，从小到大排列即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 步骤2函数int findMin(vector&lt;int&gt; nums, int i) { int pivotEle = nums[i-1]; for (i = nums.size() - 1; i &gt; -1; i--) { if (nums[i] &gt; pivotEle) { break; } } return i;}// 步骤4函数，也可以用 reverse(nums.begin()+i, nums.end());实现void swap(vector&lt;int&gt; &amp;nums, int i) { int end = nums.size() - 1; while (i &lt; end) { int temp = nums[i]; nums[i] = nums[end]; nums[end] = temp; i++; end--; }}class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int i; for(i = nums.size()-1; i&gt;0; i--){ // 步骤1 if(nums[i] &gt; nums[i-1]) { int minIndex = findMin(nums, i); //步骤3 int minEle = nums[minIndex]; nums[minIndex] = nums[i-1]; nums[i-1] = minEle; swap(nums, i); break; } } if(0 == i) { sort(nums.begin(), nums.end()); } }}; 题目46:全排列 描述： 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 思路一： 突破点：回溯法。 步骤（以[2, 5, 8, 9, 10]为例）： 定义backtrack(first, ouput)函数，表示从左到右填到第first个位置，当前排列为ouput，进行递归； 如果n==first，证明已经填完，结束递归； 如果n&gt;first，可通过标记数组标记已经填过的数，填入未标记的数字后，调用backtrack(first+1, output)； 优化空间：将标记数组划分为左右两部分，左边已填过，右边未填过，动态维护。 例：[2, 5, 8, 9, 10]中已经填了[8, 9]，此时数组为[8, 9 | 2, 5, 10]，要填10，则交换2和10，数组变为[8, 9, 10 | 2, 5]。 代码： 123456789101112131415161718192021222324class Solution {public: void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len){ if (first == len) { // 关于emplace_back有专门的文章 res.emplace_back(output); return; } for (int i = first; i &lt; len; ++i) { // 动态维护数组 swap(output[i], output[first]); // 继续递归填下一个数 backtrack(res, output, first + 1, len); // 撤销操作 swap(output[i], output[first]); } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt; &gt; res; backtrack(res, nums, 0, (int)nums.size()); return res; }}; 思路二：（注意输出顺序与题目要求不符） 突破点：递归。 步骤（以[1, 2, 3]为例）： 数组中每一个元素与最后一个元素互换； 例：[1, 2, 3]得到：[3, 2, 1]、[1, 3, 2]、[1, 2, 3]； 将最后一个元素进行保存，考虑剩余元素，对剩余元素进行递归全排列求解； 例：对1.中[3, 2, 1]，递归求解[3, 2]得到[[3, 2], [2, 3]]； 将2.中保存的最后元素加入子序列，得到结果； 例：对2.中，得到[[3, 2, 1], [2, 3, 1]]； 继续循环完成剩余情况。 例：[1, 2, 3]剩余[1, 3, 2]和[1, 2, 3]。 代码： 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt; &gt; ans; if(1 == nums.size()) { ans.push_back(nums); return ans; } else { vector&lt;vector&lt;int&gt; &gt; tempAns; vector&lt;int&gt; ncp = nums; //步骤4 for(int i = 0; i &lt; nums.size(); i++) { //步骤1 int temp = nums[i]; nums[i] = nums[nums.size()-1]; nums[nums.size()-1] = temp; //步骤2 int end = nums[nums.size()-1]; nums.pop_back(); tempAns=permute(nums); //步骤3 for (auto j : tempAns) { j.push_back(end); ans.push_back(j); } nums = ncp; } return ans; } } }; 题目79:单词搜索 描述： 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]给定 word = &quot;ABCCED&quot;, 返回 true给定 word = &quot;SEE&quot;, 返回 true给定 word = &quot;ABCB&quot;, 返回 false 提示： board 和 word 中只包含大写和小写英文字母。 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 1 &lt;= word.length &lt;= 10^3 思路： 突破点：深度优先搜索。 步骤（以ABCCEE为例）： 采用暴力搜索找到第一个字符； 例：ABCCEE中的A； 按照深度优先搜索寻找是否有匹配字符串，找到返回true，没有则寻找下一个第一字符； 例：如果没找到，继续寻找下一个A； 为了避免重复，将搜索过的字符置为0。 代码： 12345678910111213141516171819202122232425262728293031class Solution {public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { if(0 == board.size()) { return false; } for (int i= 0; i &lt; board.size(); i++) { for(int j = 0; j &lt; board[0].size(); j++) { if (dfs(board, word, i, j, 0)){ return true; } } } return false; } bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word, int i,int j,int length){ if (i &gt;= board.size() || j &gt;= board[0].size() || i &lt; 0 || j &lt; 0 || length &gt;= word.size() || word[length] != board[i][j]) { return false; } if(length == word.size()-1 &amp;&amp; word[length] == board[i][j]) { return true; } char temp = board[i][j]; board[i][j] = '0'; bool flag = dfs(board, word, i, j+1, length+1) || dfs(board, word, i, j-1, length+1) || dfs(board, word, i+1, j, length+1) || dfs(board, word, i-1, j, length+1); // 标记过的点恢复原状，以便进行下一次搜索 board[i][j] = temp; return flag; }}; 题目212:单词搜索II 描述： 给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。 示例: 输入:words = [“oath”,”pea”,”eat”,”rain”] and board =[ [‘o’,’a’,’a’,’n’], [‘e’,’t’,’a’,’e’], [‘i’,’h’,’k’,’r’], [‘i’,’f’,’l’,’v’]] 输出: [“eat”,”oath”]说明:你可以假设所有输入都由小写字母 a-z 组成。 提示: 你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。 思路： 突破点：前缀树。 步骤： 对于board使用DFS； 使用前缀树，在递归遍历前缀树时，在当前字符不同时分开遍历。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct Node { bool word; string str; unordered_map&lt;char, Node*&gt; words;};class Trie {public: Trie() { root = new Node(); } void insert(string word) { Node* p = root; for (char c: word) { if (p-&gt;words.find(c) == p-&gt;words.end()) { Node* t = new Node(); p-&gt;words[c] = t; } p = p-&gt;words[c]; } // node对应的word，为了之后根据node来找到结果 p-&gt;str = word; p-&gt;word = true; } void search(vector&lt;string&gt;&amp; res, vector&lt;vector&lt;char&gt;&gt;&amp; board) { for (int i = 0; i &lt; board.size(); i++) { for (int j = 0; j &lt; board[i].size(); j++) { help(res, board, root, i, j); } } } void help(vector&lt;string&gt;&amp;res, vector&lt;vector&lt;char&gt;&gt;&amp; board, Node* p, int x, int y) { if (p-&gt;word) { // 其他方向就不会再把答案放进去了 p-&gt;word = false; res.push_back(p-&gt;str); return; } if (x &lt; 0 || x == board.size() || y &lt; 0 || y == board[x].size()) return; if (p-&gt;words.find(board[x][y]) == p-&gt;words.end()) return; // 此时的p是其他字符了 p = p-&gt;words[board[x][y]]; char cur = board[x][y]; board[x][y] = '0'; help(res, board, p, x+1, y); help(res, board, p, x-1, y); help(res, board, p, x, y+1); help(res, board, p, x, y-1); board[x][y] = cur; } private: Node* root;};class Solution {public: vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) { Trie trie; vector&lt;string&gt; res; for (string&amp; w: words) { trie.insert(w); } trie.search(res, board); return res; }}; 题目84:柱状图中最大的矩形 描述： 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 例，给定的高度为 [2,1,5,6,2,3]。 所能勾勒出的最大矩形面积为 10 个单位。 思路： 突破点：单调栈。 步骤： 对于每一个高度，利用单调栈获取向左和向右的边界； 对每个高度求一次面积； 遍历所有高度，求出最大面积。 代码： 1234567891011121314151617int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int ans = 0; vector&lt;int&gt; monoStack; heights.insert(heights.begin(), 0); heights.push_back(0); for (int i = 0; i &lt; heights.size(); i++) { while (!monoStack.empty() &amp;&amp; heights[monoStack.back()] &gt; heights[i]) { int cur = monoStack.back(); monoStack.pop_back(); int left = monoStack.back() + 1; int right = i - 1; ans = max(ans, (right - left + 1) * heights[cur]); } monoStack.push_back(i); } return ans;} 题目85:最大矩形 描述： 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例: 输入:[ [“1”,”0”,”1”,”0”,”0”], [“1”,”0”,”1”,”1”,”1”], [“1”,”1”,”1”,”1”,”1”], [“1”,”0”,”0”,”1”,”0”]]输出: 6 思路： 突破点：动态规划。 步骤： heights[i][j]代表[i, j]的高度； dp[i][j][p]代表以[i, j]为右下角，高度为k可以组成的面积。 代码： 1234567891011121314151617181920212223242526class Solution {public: int maximalRectangle(vector&lt;vector&lt;char&gt; &gt;&amp; matrix) { int n = matrix.size(); int m = 0; if (n &gt; 0) { m = matrix[0].size(); } vector&lt;vector&lt;int&gt; &gt; heights(n+1, vector&lt;int&gt;(m+1, 0)); vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; dp(n+1, vector&lt;vector&lt;int&gt; &gt;(m+1, vector&lt;int&gt;(n+1, 0))); int ans = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if ('0' == matrix[i-1][j-1]) { continue; } heights[i][j] = heights[i-1][j] + 1; for (int k = 1; k &lt;= heights[i][j]; k++) { dp[i][j][k] = dp[i][j-1][k] + k; ans = max(ans, dp[i][j][k]); } } } return ans; }}; 题目153:寻找旋转排序数组中的最小值 描述： 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2]输出: 1 思路： 突破点：二分查找。 代码： 12345678910111213141516class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int left = 0; int right = nums.size() - 1; while (left &lt; right) { int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) { left = mid + 1; } else { right = mid; } } return nums[left]; }}; 题目154:寻找旋转排序数组中的最小值 II 描述： 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 注意数组中可能存在重复的元素。 示例 1： 输入: [1,3,5]输出: 1示例 2： 输入: [2,2,2,0,1]输出: 0说明： 这道题是 寻找旋转排序数组中的最小值 的延伸题目。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？ 思路： 突破点：二分查找。 代码： 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { if(nums.empty()) return -1; if(1 == nums.size()) return nums[0]; int p1 = 0, p2 = nums.size() - 1; // 假如旋转了数组的前面0个元素（也就是没有旋转），我们直接返回numbers[p1] int mid = p1; while(nums[p1] &gt;= nums[p2]) { if(1 == p2 - p1) { // 循环终止条件：当p2-p1=1时，p2所指元素为最小值 mid = p2; break; } // 二分法找中点 mid = (p2 + p1) / 2; // 特殊情况：p1、mid、p2三处的元素的值一样，无法判断最小值在mid前面还是后面，就只能顺序查找了 if(nums[p1] == nums[p2] &amp;&amp; nums[p1] == nums[mid]) return findMin(nums, p1, p2); // 缩小范围，mid处值大于等于p1处值的话，说明最小值在mid处或mid后面，故将p1挪到mid处 if(nums[mid] &gt;= nums[p1]) p1 = mid; // 缩小范围，mid处值小于p1处值的话，说明最小值在mid处或mid前面，故将p2挪到mid处 else p2 = mid; } return nums[mid]; } // 顺序查找 int findMin(vector&lt;int&gt;&amp; nums, int p1, int p2) { int res = nums[p1]; for(int i=p1+1; i&lt;=p2; ++i) { if(nums[i] &lt; res) return nums[i]; } return res; }};","link":"/2020/09/06/2020-09-06-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Array/"},{"title":"LeetCode题目总结-Two Pointer+Linked List","text":"题目3:无重复字符的最长子串 描述： 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 思路一： 突破点：滑动窗口。 步骤： 设立指针a和指针b； b指针向右伸缩，对于每个A[b]判断是否之前出现过； 若出现，则a指向出现过的未知的下一位置，更新右指针和最大长度。 代码： 1234567891011121314151617181920212223class Solution {public: int lengthOfLongestSubstring(string s) { //s[start,end) 前面包含 后面不包含 int start(0), end(0), length(0), result(0); int stringSize = int(s.size()); while (end &lt; stringSize) { char tmpChar = s[end]; for (int index = start; index &lt; end; index++) { if (tmpChar == s[index]) { start = index + 1; length = end - start; break; } } end++; length++; result = max(result, length); } return result; }}; 思路二： 突破点：hashMap。 步骤： 与思路一类似； 在判断是否出现过时，使用hashmap优化时间。 b指针向右伸缩，对于每个A[b]判断是否之前出现过； 若出现，则a指向出现过的未知的下一位置，更新右指针和最大长度。 代码： 12345678910111213141516171819202122232425class Solution {public: int lengthOfLongestSubstring(string s) { //s[start,end) 前面包含 后面不包含 int start(0), end(0), length(0), result(0); int sSize = int(s.size()); unordered_map&lt;char, int&gt; hash; while (end &lt; sSize) { char tmpChar = s[end]; //仅当s[start,end) 中存在s[end]时更新start if (hash.find(tmpChar) != hash.end() &amp;&amp; hash[tmpChar] &gt;= start) { start = hash[tmpChar] + 1; length = end - start; } hash[tmpChar] = end; end++; length++; result = max(result, length); } return result; }}; 题目75:颜色分类 描述： 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2]进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 思路： 突破点：三指针。 步骤： 定义三个指针p0、p2、curr来追踪0、2的边界以及当前考虑的元素； 初始化p0 = 0，p2 = n-1； 当curr&lt;=p2时，如果nums[curr] = 0，则交换curr和p0所指元素，并将curr和p0右移； 如果nums[curr] = 2，则交换curr和p2所指元素，并将p2左移，注意此时为了将判断移过来的元素类型而不右移curr； 如果nums[curr] = 1，则curr右移。 代码： 1234567891011121314151617181920212223class Solution { public: /* 荷兰三色旗问题解 */ void sortColors(vector&lt;int&gt;&amp; nums) { // 对于所有 idx &lt; p0 : nums[idx &lt; p0] = 0 // curr 是当前考虑元素的下标 int p0 = 0, curr = 0; // 对于所有 idx &gt; p2 : nums[idx &gt; p2] = 2 int p2 = nums.size() - 1; while (curr &lt;= p2) { if (nums[curr] == 0) { swap(nums[curr++], nums[p0++]); } else if (nums[curr] == 2) { swap(nums[curr], nums[p2--]); } else curr++; } }}; 题目88:合并两个有序数组 描述： 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 思路: 突破点：归并排序思想。 步骤： 获取nums1数组的尾部指针； 从两数组尾部开始，交换较大值和nums1尾部位置。 代码： 1234567891011void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int i = nums1.size() - 1; m--; n--; while (n &gt;= 0) { while (m &gt;= 0 &amp;&amp; nums1[m] &gt; nums2[n]) { swap(nums1[i--], nums1[m--]); } swap(nums1[i--], nums2[n--]); }} 题目125:验证回文串 描述：给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 思路： 突破点：首尾指针比较。 步骤： 一个指针指向头部，一个指针指向尾部； 分别从首尾开始比较，数字全部转化为小写比较； 如果有不同，则返回false。 代码： 1234567891011class Solution {public: bool isPalindrome(string s) { for (int i = 0, j = s.length() - 1; i &lt; j; i ++, j --) { while(i &lt; j &amp;&amp; !isalnum(s[i])) i ++; while(i &lt; j &amp;&amp; !isalnum(s[j])) j --; if(tolower(s[i]) != tolower(s[j])) return false; } return true; }}; 题目76:最小覆盖子串 描述： 给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。 示例： 输入：S = “ADOBECODEBANC”, T = “ABC”输出：”BANC” 提示： 如果 S 中不存这样的子串，则返回空字符串 “”。如果 S 中存在这样的子串，我们保证它是唯一的答案。 思路： 突破点：滑动窗口。 步骤： 声明两个指针left和right，right用于延伸窗口，left用于收缩窗口； 首先移动right使得窗口内包含t所有字符； 然后收缩left且保证收缩过程中t仍在窗口内； 使用哈希表动态维护窗口中字符数以及t中字符数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: unordered_map &lt;char, int&gt; ori, cnt; // 步骤4 bool check() { for (const auto &amp;p: ori) { if (cnt[p.first] &lt; p.second) { return false; } } return true; } // 滑窗 string minWindow(string s, string t) { for (const auto &amp;c: t) { ++ori[c]; } // 步骤1 int l = 0, r = -1; int len = INT_MAX, ansL = -1, ansR = -1; // 步骤2 while (r &lt; int(s.size())) { if (ori.find(s[++r]) != ori.end()) { ++cnt[s[r]]; } // 步骤3 while (check() &amp;&amp; l &lt;= r) { if (r - l + 1 &lt; len) { len = r - l + 1; ansL = l; } if (ori.find(s[l]) != ori.end()) { --cnt[s[l]]; } ++l; } } return ansL == -1 ? string() : s.substr(ansL, len); }}; 题目206:反转链表 描述： 反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 思路一： 突破点：双指针。 步骤： 定义一前一后两个指针pre和cur； 每次让pre的next指向cur，实现局部反转； 局部反转后，两个指针同时前移一位，直到pre到达链表结尾。 代码： 12345678910111213class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* cur = nullptr, *pre = head; while (nullptr != pre) { ListNode* t = pre-&gt;next; pre-&gt;next = cur; cur = pre; pre = t; } return cur; }}; 思路二： 突破点：递归。 步骤： 一直递归到链表最后一个节点； 每次返回时，让当前节点的下一节点的next指针指向当前节点； 让当前节点的next指针指向nullptr； 递归函数全部出栈后，反转完成。 代码： 123456789101112class Solution {public: ListNode* reverseList(ListNode* head) { if (nullptr == head || nullptr == head-&gt;next) { return head; } ListNode* ret = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return ret; }}; 题目21:合并两个有序链表 描述： 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路： 突破点：递归。 步骤： 递归时，首先比较两个输入头节点的大小； 若list1小于list2的头节点，则尾部添加list1后继续递归； 若list1大于list2的头节点，则尾部添加list2后继续递归。 代码： 12345678910111213141516class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if (nullptr == l1) { return l2; } else if (nullptr == l2) { return l1; } else if (l1-&gt;val &lt; l2-&gt;val) { l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } else { l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; } }}; 题目23:合并K个升序链表 描述： 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6示例 2： 输入：lists = []输出：[]示例 3： 输入：lists = [[]]输出：[] 提示： k == lists.length0 &lt;= k &lt;= 10^40 &lt;= lists[i].length &lt;= 500-10^4 &lt;= lists[i][j] &lt;= 10^4lists[i] 按 升序 排列lists[i].length 的总和不超过 10^4 思路一： 突破点：分治合并。 步骤： 将k个链表配对，并两两合并； 重复1.中过程，直到得到最终链表。 代码： 123456789101112131415161718192021222324252627282930class Solution {public: ListNode* mergeTwoLists(ListNode *a, ListNode *b) { if ((!a) || (!b)) return a ? a : b; ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b; while (aPtr &amp;&amp; bPtr) { if (aPtr-&gt;val &lt; bPtr-&gt;val) { tail-&gt;next = aPtr; aPtr = aPtr-&gt;next; } else { tail-&gt;next = bPtr; bPtr = bPtr-&gt;next; } tail = tail-&gt;next; } tail-&gt;next = (aPtr ? aPtr : bPtr); return head.next; } ListNode* merge(vector &lt;ListNode*&gt; &amp;lists, int l, int r) { if (l == r) return lists[l]; if (l &gt; r) return nullptr; int mid = (l + r) &gt;&gt; 1; return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r)); } ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { return merge(lists, 0, lists.size() - 1); }}; 思路二： 突破点：优先队列。 步骤： 维护当前每个链表没有别合并的元素最前面的一个； 每次在1.中选取val值最小的元素合并到result中； 使用优先队列进行优化。 代码： 1234567891011121314151617181920212223242526class Solution {public: struct Status { int val; ListNode *ptr; bool operator &lt; (const Status &amp;rhs) const { return val &gt; rhs.val; } }; priority_queue &lt;Status&gt; q; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { for (auto node: lists) { if (node) q.push({node-&gt;val, node}); } ListNode head, *tail = &amp;head; while (!q.empty()) { auto f = q.top(); q.pop(); tail-&gt;next = f.ptr; tail = tail-&gt;next; if (f.ptr-&gt;next) q.push({f.ptr-&gt;next-&gt;val, f.ptr-&gt;next}); } return head.next; }};","link":"/2020/09/06/2020-09-06-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Two-Pointer+Linked-List/"},{"title":"LeetCode题目总结-Tree+BST","text":"题目94:二叉树的中序遍历 描述： 给定一个二叉树，返回它的中序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [1,3,2]进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 思路一： 突破点：递归。 代码： 123456void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (nullptr == cur) return; traversal(cur-&gt;left, vec); // 左 vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;right, vec); // 右} 思路二： 突破点：迭代。 代码： 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; tempStack; if (nullptr != root) tempStack.push(root); while (!tempStack.empty()) { TreeNode* node = tempStack.top(); if (nullptr != node) { // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 tempStack.pop(); // 添加右节点 if (node-&gt;right) tempStack.push(node-&gt;right); // 添加中节点 tempStack.push(node); // 中节点访问过，但是还没有处理，需要做一下标记。 tempStack.push(nullptr); // 添加左节点 if (node-&gt;left) tempStack.push(node-&gt;left); } else { // 将空节点弹出 tempStack.pop(); // 重新取出栈中元素 node = tempStack.top(); tempStack.pop(); // 加入到数组中 result.push_back(node-&gt;val); } } return result; }}; 题目144:二叉树的前序遍历 描述： 给定一个二叉树，返回它的 前序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [1,2,3]进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 思路一： 突破点：递归。 代码： 1234567891011121314class Solution {public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (nullptr == cur) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; }}; 思路二： 突破点：迭代。 代码： 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; tempStack; if (nullptr != root) tempStack.push(root); while (!tempStack.empty()) { TreeNode* node = tempStack.top(); if (nullptr != node) { tempStack.pop(); if (node-&gt;right) tempStack.push(node-&gt;right); // 右 if (node-&gt;left) tempStack.push(node-&gt;left); // 左 tempStack.push(node); // 中 tempStack.push(NULL); } else { tempStack.pop(); node = tempStack.top(); tempStack.pop(); result.push_back(node-&gt;val); } } return result; }}; 题目145:二叉树的后序遍历 描述： 给定一个二叉树，返回它的 后序 遍历。 示例: 输入: [1,null,2,3] 1 2 / 3 输出: [3,2,1]进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 思路一： 突破点：递归。 代码： 1234567891011121314class Solution {public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (nullptr == cur) return; traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 vec.push_back(cur-&gt;val); // 中 } vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; }}; 思路二： 突破点：迭代。 代码： 12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; tempStack; if (nullptr != root) tempStack.push(root); while (!tempStack.empty()) { TreeNode* node = tempStack.top(); if (nullptr != node) { tempStack.pop(); tempStack.push(node); // 中 tempStack.push(NULL); if (node-&gt;right) tempStack.push(node-&gt;right); // 右 if (node-&gt;left) tempStack.push(node-&gt;left); // 左 } else { tempStack.pop(); node = tempStack.top(); tempStack.pop(); result.push_back(node-&gt;val); } } return result; }}; 题目112:路径总和 描述：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 思路一： 突破点：广度优先搜索。 步骤： 使用广度优先搜索，计算从根节点到当前节点的路径和； 使用两个队列，分别存储要遍历的节点和根节点到这些节点的路径和。 代码： 12345678910111213141516171819202122232425262728293031class Solution {public: bool hasPathSum(TreeNode *root, int sum) { if (nullptr == root) { return false; } queue&lt;TreeNode *&gt; queNode; queue&lt;int&gt; queVal; queNode.push(root); queVal.push(root-&gt;val); while (!queNode.empty()) { TreeNode *now = queNode.front(); int temp = queVal.front(); queNode.pop(); queVal.pop(); if (nullptr ==now-&gt;left &amp;&amp; nullptr == now-&gt;right) { if (temp == sum) return true; continue; } if (nullptr != now-&gt;left) { queNode.push(now-&gt;left); queVal.push(now-&gt;left-&gt;val + temp); } if (now-&gt;right != nullptr) { queNode.push(now-&gt;right); queVal.push(now-&gt;right-&gt;val + temp); } } return false; }}; 思路二： 突破点：递归。 步骤： 问题细化，即为求是否存在从当前节点的子节点到叶子节点的路径，使得路径和为sum-val； 若当前节点为叶子节点，则直接判断sum是否与val相等； 若非叶子节点，需递归进行查询。 代码： 12345678910111213class Solution {public: bool hasPathSum(TreeNode *root, int sum) { if (nullptr == root) { return false; } if (nullptr == root-&gt;left &amp;&amp; nullptr == root-&gt;right) { return sum == root-&gt;val; } return hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val); }}; 题目113:路径总和 II 描述：给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1 返回: 1234[ [5,4,11,2], [5,8,4,5]] 思路： 突破点：DFS。 步骤： 递归记录当前路径上所有节点的值； 当递归至叶子节点，计算路径总和并比较。 代码： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt; &gt; ans; void dfs(TreeNode* root, int sum, vector&lt;int&gt; valVec){ valVec.push_back(root-&gt;val); if(nullptr == root-&gt;left &amp;&amp; nullptr == root-&gt;right){ int s = 0; for(auto n: valVec) s += n; if(s == sum) ans.push_back(valVec); } if(root-&gt;left) dfs(root-&gt;left, sum, valVec); if(root-&gt;right) dfs(root-&gt;right, sum, valVec); } vector&lt;vector&lt;int&gt; &gt; pathSum(TreeNode* root, int sum) { if(root == NULL) return ans; dfs(root, sum, {}); return ans; }}; 题目235:二叉搜索树的最近公共祖先 描述： 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。 思路： 突破点：递归。 步骤： 分左右两边进行递归； 如果左边没有找到，说明公共祖先在右边； 如果右边没有找到，说明公共祖先在左边； 如果左右均不为空，则说明找到了。 代码： 12345678910111213TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //递归边界返回空或者返回存在的那个结点 if(nullptr == root || root == p || root == q) return root; //左边找一找 TreeNode* leftNode = lowestCommonAncestor(root-&gt;left,p,q); //右边找一找 TreeNode* rightNode = lowestCommonAncestor(root-&gt;right,p,q); //返回NULL或者有的那一侧 if(nullptr == leftNode)return rightNode; if(nullptr == rightNode)return leftNode; //当前祖先左边有p，右边有q return root; } 题目1382:将二叉搜索树变平衡 描述： 给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。 如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。 如果有多种构造方法，请你返回任意一种。 示例： 输入：root = [1,null,2,null,3,null,4,null,null]输出：[2,1,3,null,null,null,4]解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。 提示： 树节点的数目在 1 到 10^4 之间。树节点的值互不相同，且在 1 到 10^5 之间。 思路： 突破点：DFS。 步骤： 使用升序数组构造平衡二叉搜索树； 设长度为n，则n/2处元素为根节点； 递归进行构造。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution { void dfs(TreeNode *root, vector&lt;int&gt; &amp;vec) { if(nullptr == root) { return; } dfs(root-&gt;left, vec); vec.push_back(root-&gt;val); dfs(root-&gt;right, vec); } TreeNode* construct(const vector&lt;int&gt; &amp;vec, int leftVal, int rightVal) { if(leftVal &gt; rightVal) { return nullptr; } int mid = (leftVal+rightVal)&gt;&gt;1; auto ptr = new TreeNode(vec[mid]); ptr-&gt;right = construct(vec, mid+1, rightVal); ptr-&gt;left = construct(vec, leftVal, mid-1); return ptr; } public: TreeNode* balanceBST(TreeNode* root) { if(nullptr == root) { return nullptr; } vector&lt;int&gt; data; dfs(root, data); return construct(data, 0, data.size()-1); }};","link":"/2020/09/07/2020-09-07-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Tree+BST/"},{"title":"LeetCode题目总结-DFS+BFS","text":"题目116:填充每个节点的下一个右侧节点指针 描述： 给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node { int val; Node *left; Node *right; Node *next;} 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例： 输入：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1} 输出：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1} 提示： 你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 思路： 突破点：广度优先搜索。 步骤： 使用队列进行广度优先遍历； 在接点出队列后，next指向队列首个元素，广度遍历完直接return。 代码： 123456789101112131415161718192021222324252627282930313233class Solution {public: Node* connect(Node* root) { if(!root) return root; queue&lt;Node*&gt; work; work.push(root); work.push(nullptr); Node* cur = nullptr; while(1) { // 如果队列首部是结点 if(work.front()) { cur = work.front(); work.pop(); // 如果是非叶子结点 if(cur-&gt;left) { work.push(cur-&gt;left); work.push(cur-&gt;right); } cur-&gt;next = work.front(); } // 如果只剩下一个nullptr结点 else if (1 == work.size()) { return root; } // 如果遇到nullptr结点，这是一层的分割点 else { work.pop(); work.push(nullptr); } } return root; }}; 题目117:填充每个节点的下一个右侧节点指针 II 描述： 给定一个二叉树 struct Node { int val; Node *left; Node *right; Node *next;}填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 进阶： 你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例： 输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#] 提示： 树中的节点数小于 6000-100 &lt;= node.val &lt;= 100 思路： 突破点：层次遍历。 步骤： 使用队列层次遍历； 每循环一层将这一层清空，录入孩子节点。 代码： 123456789101112131415161718192021222324252627class Solution {public: Node* connect(Node* root) { if(!root) { return root; } queue&lt;Node*&gt; q{{root}}; while(!q.empty()) { int n = q.size(); for(int i = 0; i &lt; n; i++){ Node* t = q.front(); q.pop(); if(n-1 != i){ Node* tNext = q.front(); t-&gt;next = tNext; } if(t-&gt;left) { q.push(t-&gt;left); } if(t-&gt;right) { q.push(t-&gt;right); } } } return root; }}; 题目200:岛屿数量 描述： 给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1: 输入:[[‘1’,’1’,’1’,’1’,’0’],[‘1’,’1’,’0’,’1’,’0’],[‘1’,’1’,’0’,’0’,’0’],[‘0’,’0’,’0’,’0’,’0’]]输出: 1示例 2: 输入:[[‘1’,’1’,’0’,’0’,’0’],[‘1’,’1’,’0’,’0’,’0’],[‘0’,’0’,’1’,’0’,’0’],[‘0’,’0’,’0’,’1’,’1’]]输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 思路一： 突破点：深度优先搜索。 步骤： 将二维网格视为无向图，相邻1之间有边相连； 搜索到1，则标记为0； 最终深度优先搜索次数即为岛屿数量。 代码： 12345678910111213141516171819202122232425262728293031class Solution {private: void dfs(vector&lt;vector&lt;char&gt; &gt;&amp; grid, int r, int c) { int nr = grid.size(); int nc = grid[0].size(); grid[r][c] = '0'; if ('1' == r - 1 &gt;= 0 &amp;&amp; grid[r-1][c]) dfs(grid, r - 1, c); if ('1' == r + 1 &lt; nr &amp;&amp; grid[r+1][c]) dfs(grid, r + 1, c); if ('1' == c - 1 &gt;= 0 &amp;&amp; grid[r][c-1]) dfs(grid, r, c - 1); if ('1' == c + 1 &lt; nc &amp;&amp; grid[r][c+1]) dfs(grid, r, c + 1); }public: int numIslands(vector&lt;vector&lt;char&gt; &gt;&amp; grid) { int nr = grid.size(); if (!nr) return 0; int nc = grid[0].size(); int num_islands = 0; for (int r = 0; r &lt; nr; ++r) { for (int c = 0; c &lt; nc; ++c) { if ('1' == grid[r][c]) { ++num_islands; dfs(grid, r, c); } } } return num_islands; }}; 思路二： 突破点：广度优先搜索。 步骤： 将二维网格视为无向图，相邻1之间有边相连； 搜索到1，则加入队列，并修改标记为0； 最终广度优先搜索次数即为岛屿数量。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int numIslands(vector&lt;vector&lt;char&gt; &gt;&amp; grid) { int nr = grid.size(); if (!nr) return 0; int nc = grid[0].size(); int num_islands = 0; for (int r = 0; r &lt; nr; ++r) { for (int c = 0; c &lt; nc; ++c) { if (grid[r][c] == '1') { ++num_islands; grid[r][c] = '0'; queue&lt;pair&lt;int, int&gt; &gt; neighbors; neighbors.push({r, c}); while (!neighbors.front()) { auto rc = neighbors.front(); neighbors.pop(); int row = rc.first, col = rc.second; if (0 &lt;= row - 1 &amp;&amp; '1' == grid[row-1][col]) { neighbors.push({row-1, col}); grid[row-1][col] = '0'; } if (row + 1 &lt; nr &amp;&amp; grid[row+1][col] == '1') { neighbors.push({row+1, col}); grid[row+1][col] = '0'; } if (col - 1 &gt;= 0 &amp;&amp; grid[row][col-1] == '1') { neighbors.push({row, col-1}); grid[row][col-1] = '0'; } if (col + 1 &lt; nc &amp;&amp; grid[row][col+1] == '1') { neighbors.push({row, col+1}); grid[row][col+1] = '0'; } } } } } return num_islands; }}; 题目207:课程表 描述： 你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例 1: 输入: 2, [[1,0]]输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。示例 2: 输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示： 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。1 &lt;= numCourses &lt;= 10^5 思路一： 突破点：深度优先搜索。 步骤： 题目即寻找有向图中是否成环； 通过深度优先搜索，寻找拓扑排序； 如果存在，说明无环，如果不存在，说明有环。 代码： 12345678910111213141516171819202122232425262728293031323334353637class Solution {private: vector&lt;vector&lt;int&gt; &gt; edges; vector&lt;int&gt; visited; bool valid = true;public: void dfs(int u) { visited[u] = 1; for (int v: edges[u]) { if (0 == visited[v]) { dfs(v); if (!valid) { return; } } else if (1 == visited[v]) { valid = false; return; } } visited[u] = 2; } bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) { edges.resize(numCourses); visited.resize(numCourses); for (const auto&amp; info: prerequisites) { edges[info[1]].push_back(info[0]); } for (int i = 0; i &lt; numCourses &amp;&amp; valid; ++i) { if (!visited[i]) { dfs(i); } } return valid; }}; 思路二： 突破点：广度优先搜索。 步骤： 题目即寻找有向图中是否成环； 通过广度优先搜索，寻找拓扑排序； 寻找所有入度为0的点放入队列； 每一步广度优先搜索时，取出队首节点，加入答案中； 移除该点的所有出边； 如果有某个相邻节点入度变为0，则将该节点加入答案； 结束后，如果答案包含n各节点，则找到一种拓扑排序； 否则，说明存在环。 代码： 123456789101112131415161718192021222324252627282930313233343536class Solution {private: vector&lt;vector&lt;int&gt; &gt; edges; vector&lt;int&gt; indeg;public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) { edges.resize(numCourses); indeg.resize(numCourses); for (const auto&amp; info: prerequisites) { edges[info[1]].push_back(info[0]); ++indeg[info[0]]; } queue&lt;int&gt; q; for (int i = 0; i &lt; numCourses; ++i) { if (0 == indeg[i]) { q.push(i); } } int visited = 0; while (!q.empty()) { ++visited; int u = q.front(); q.pop(); for (int v: edges[u]) { --indeg[v]; if (0 == indeg[v]) { q.push(v); } } } return visited == numCourses; }}; 题目210:课程表 II 描述： 现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例 1: 输入: 2, [[1,0]]输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。示例 2: 输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。说明: 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。拓扑排序也可以通过 BFS 完成。 思路： 突破点：深度优先搜索。 步骤： 思考过程与题目207类似； 当我们标记当前节点u为”搜索中“后，遍历每个相邻节点v； 如果为未搜索，则开始搜索v，搜索完成后回溯到u； 如果为搜索中，则找到一个环，返回false； 如果为已完成，说明v已经在栈中，不进行操作； u所有相邻节点都为”已完成“后，将u入栈，并标记为已完成。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution {private: // 存储有向图 vector&lt;vector&lt;int&gt; &gt; edges; // 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成 vector&lt;int&gt; visited; // 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶 vector&lt;int&gt; result; // 判断有向图中是否有环 bool valid = true;public: void dfs(int u) { // 将节点标记为「搜索中」 visited[u] = 1; // 搜索其相邻节点 // 只要发现有环，立刻停止搜索 for (int v: edges[u]) { // 如果「未搜索」那么搜索相邻节点 if (visited[v] == 0) { dfs(v); if (!valid) { return; } } // 如果「搜索中」说明找到了环 else if (visited[v] == 1) { valid = false; return; } } // 将节点标记为「已完成」 visited[u] = 2; // 将节点入栈 result.push_back(u); } vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { edges.resize(numCourses); visited.resize(numCourses); for (const auto&amp; info: prerequisites) { edges[info[1]].push_back(info[0]); } // 每次挑选一个「未搜索」的节点，开始进行深度优先搜索 for (int i = 0; i &lt; numCourses &amp;&amp; valid; ++i) { if (!visited[i]) { dfs(i); } } if (!valid) { return {}; } // 如果没有环，那么就有拓扑排序 // 注意下标 0 为栈底，因此需要将数组反序输出 reverse(result.begin(), result.end()); return result; }}; 题目279:完全平方数 描述： 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12输出: 3解释: 12 = 4 + 4 + 4.示例 2: 输入: n = 13输出: 2解释: 13 = 4 + 9. 思路一： 突破点：广度优先搜索。 步骤： 将题目抽象为从n走到0，每次跨越平方距离，求最少跨越次数； 使用BFS解决。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: /*返回小于n的平方序列: 1, 4, 9...*/ vector&lt;int&gt; getSquares(int n) { vector&lt;int&gt; res; for(int i = 1; i*i &lt;= n; ++i) { res.push_back(i*i); } return res; } int numSquares(int n) { vector&lt;int&gt; squares = getSquares(n); vector&lt;bool&gt; visited(n+1); //记录已访问过的节点 queue&lt;int&gt; q; q.push(n); int res = 0; visited[n] = true; while(!q.empty()) { int size = q.size(); res++; while(size--) { int curr = q.front(); q.pop(); /*每次跨越的间隔为平方数*/ for(int num: squares) { int next = curr - num; if(0 &gt; next) { break; } if(0 == next) { return res; } visited[next] = true; q.push(next); } } } return n; }}; 思路二： 突破点：动态规划。 步骤： 将题目理解为背包问题； 背包容量v[i]表示每个完全平方数字的大小； 背包价值w[i]为1； 求解组成数组所需要的完全平方数数量最少即为背包的价值最低。 代码： 123456789101112131415161718192021222324252627282930class Solution {public: int numSquares(int n) { vector&lt;int&gt; choices; int res = 1; // 构造物品，即所有小于给定数字的完全平方数 while (n / res &gt;= res) { choices.push_back(res * res); res++; } const int size = choices.size(); vector&lt;int&gt; dp(n + 1, 0); // init for (int i = 0; i &lt;= n; ++i) { dp[i] = i; } // 完全背包模板 for (int i = 1; i &lt; size; ++i) { for (int j = choices[i]; j &lt;= n; ++j) { dp[j] = min(dp[j], dp[j - choices[i]] + 1); } } return dp[n]; }}; 题目301:删除无效的括号 描述： 删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。 说明: 输入可能包含了除 ( 和 ) 以外的字符。 示例 1: 输入: “()())()”输出: [“()()()”, “(())()”]示例 2: 输入: “(a)())()”输出: [“(a)()()”, “(a())()”]示例 3: 输入: “)(“输出: [“”] 思路： 突破点：深度优先遍历。 步骤： 首先遍历输入字符串，获取需要删除的左右括号个数； 递归循环进行左右删除； 当1.中计数都为0时，检查输入字符串是否有效。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution {public: bool isvalid(string s) { int cnt = 0; for (auto c : s) { if (c == '(') { cnt++; } else if (c == ')') { cnt--; if (cnt &lt; 0) return false; } } return cnt == 0; } void dfs(string s, int st, int l, int r, vector&lt;string&gt;&amp; ans) { if (l == 0 &amp;&amp; r == 0) { if (isvalid(s)) { ans.push_back(s); } return; } for (int i = st; i &lt; s.size(); i++) { if (i != st &amp;&amp; s[i] == s[i-1]) continue; if (s[i] == '(' &amp;&amp; l &gt; 0) { // 删除操作，substr(a, b):从a开始个字符组成的字符串 dfs(s.substr(0, i) + s.substr(i+1, s.size()-1-i), i, l - 1, r, ans); } if (s[i] == ')' &amp;&amp; r &gt; 0) { // 删除操作，substr(a, b):从a开始个字符组成的字符串 dfs(s.substr(0, i) + s.substr(i+1, s.size()-1-i), i, l, r - 1, ans); } } } vector&lt;string&gt; removeInvalidParentheses(string s) { int left = 0; int right = 0; vector&lt;string&gt; ans; for (auto c : s) { if (c == '(') { left++; } else if (c == ')') { if (left &gt; 0) { left--; } else { right++; } } } // left和right表示左右括号要删除的个数 dfs(s, 0, left, right, ans); return ans; }};","link":"/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"Database","slug":"Database","link":"/tags/Database/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"知识点","slug":"知识点","link":"/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}