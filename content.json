{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/04/14/hello-world/"},{"title":"KMP Algorithm","text":"Background…Once upon a time, Tom asked his father to find abab inside abcaabababaa. Tom’s dad did this in a traditional way (brute force). He compared each character of the first string with each character of the second string. When he find one character not matching, for example, the third character in the second string in this case, he start again from the second character of the second string. It went on and on and on… Moving on…Unfortunately, Tom had a bad temper about waiting. He wanted to make some change. Tom noticed that, if the n-th character in the first string happened to be not match, even if he start again, he will make a compare with that character again in the future. Therefore, Tom decided not to start from the begining each time a not match is found. He talked to his dad, “when we have a not match for the n-th character, if we consider the characters before, we do have a big match, and if so, we actually can use the head of abab to try to match the tail of abab, the longest mathing substring will be the place for us to start again.” For example, for abab, there will be 3 possible heads: a, ab, aba. And there will be 3 possible tails: b, ab, bab. The longest matching is ab, so each time there’s a not mathing, we don’t need to start from begin, instead we can start from the 3-rd character to make a comparison. Coding work…Taking the above thought into real code, c++, for example: We first need a function to generate all the longest matching for each substring of the string we are trying to search. 1234567891011121314151617int * FindLongestMatching(string first){ int * tableOfFirst = new int[first.length()]; tableOfFirst[0] = -1; int i = 0; int j = -1; while (i &lt; p.length() - 1) { if (j == -1 || first[i] == first[j]) { i++； j++； tableOfFirst[i] = j; } else { j = tableOfFirst[j]; } } return tableOfFirst;} With this function, we can make a linear time matching: 123456789101112131415161718int KMP (string first, string second) { int i = 0; int j = 0; int * tableOfFirst = FindLongestMatching(first); while (i &lt; second.length() &amp;&amp; j &lt; first.length()) { if (j == -1 || second[i] == first[j]) { i++; j++; } else { j = tableOfFirst[j]; } } if (j == first.length()){ return i-j; } return -1;} Tom is happy now.","link":"/2020/04/17/2020-04-17-KMP-Algorithm/"},{"title":"美团面经整理-1","text":"面经来源：美团后端实习一面面经 c++ 1. C++的内存管理分哪些区，分别有什么作用 C++的内存主要分为五大区：堆区、栈区、自由存储区、全局/静态存储区、常量存储区。 堆区：程序员分配释放，使用new分配内存块，使用delete归还内存空间。 栈区：编译器自动分配释放，用于存放局部变量、函数参数等。 自由存储区：程序员分配释放，使用malloc分配内存块，使用free归还内存空间。 全局区/静态区：全局变量和静态变量分配在同一块内存中。 常量存储区：存放不可修改的常量值。 2. C++源文本到可执行文件需要经历哪些阶段 预处理：将源代码和相关头文件处理成一个.i文件。 编译：将预处理的文件进行词法分析、语义分析，优化后产生相应的汇编代码。 汇编：将汇编语言代码翻译成目标机器码。 链接：把每个机器码文件按照要求连接起来，解决代码间的相互依赖问题。 3. 析构函数为什么必须是虚函数 为了保证整个派生类的对象完全被释放。 当析构函数不为虚函数时，在删除基类指针时，只会调用基类析构函数，而不调用派生类的析构函数，这样会导致基类指针指向的派生类对象析构不完全。 当析构函数为虚函数时，在删除基类指针时，会调用该指针指向派生类的析构函数，同时派生类的析构函数自动调用基类析构函数，保证对象被完全释放。 4. 虚函数和纯虚函数有什么区别 虚函数：在基类中存在定义，可以直接使用，也可以被派生类重写后使用。 纯虚函数：在基类中不存在定义，只有声明，必须在子类中定义后才能使用。 5. 虚函数的实现机制 编译器自动为存在虚函数的类生成一个虚函数表，当声明该类的对象时，放入一个隐式指针变量，指向虚函数表。 在调用方法时，系统根据不同对象的指针，寻找到对应的虚函数表，进而找到所需的函数地址进行调用。 6.野指针怎么出现的 指针变量未初始化。 指针释放后未置空。 返回指向栈内存的指针。 7. 类和结构体有什么区别 class中默认成员访问权限为private，而struct中为public。 class可以用于表示模板类型，sruct不行。 class是引用类型，struct是值类型。 class多用来存储数据量大、逻辑复杂的对象，struct多用来存储轻量级对象。 class多用于表现抽象和多级别的对象层次。 8. 什么情况会导致内存泄漏 程序循环new创建出来的对象没有及时delete掉。 delete掉一个void*类型的指针，导致没有调用到对象的析构函数。 new创建了一组对象，回收时未调用delete[]，而调用了delete，导致只有对象数组的第一个对象的析构函数得到执行并回收了内存。 9. 五种IO模型 阻塞IO：进程发起IO系统调用后，进程被阻塞，转到内核空间处理，处理完毕后返回进程。 非阻塞IO：进程发起IO系统调用后，如果内核缓冲区没有数据，返回给进程一个错误，而不会阻塞进程，如果缓冲区有数据，则将数据返回给进程。【发起IO后，内核便开始处理，一直有返回值，但是直到内核处理完才有数据。】 IO复用：多个进程的IO注册到一个复用器（select）上，select监听所有进来的IO。【同时负责很多水龙头，哪个水龙头要来水了，就打开哪一个。】 信号驱动IO：进程发起IO系统调用后，向内核注册信号处理函数，然后进程返回不阻塞，当内核数据就绪则通知进程发起IO调用读取数据。【首先用信号通知内核空间，等到数据就绪再发起IO。】 异步IO：进程发起IO系统调用后，进程返回不阻塞，等内核将IO处理完，通知进程数据结果。 10. TCP如何保证传输的可靠性 校验和：接收方和发送方均进行校验和的计算，并进行对比。 序列号：TCP传输时将每个字节的数据都进行编号。 确认应答：TCP传输过程中，每次接收方收到数据后，均对传输方进行确认应答（ACK）。 超时重传：发送方在发送完数据后进行等待，一段时间后没有收到ACK，则对刚才的数据进行重新发送。 连接管理：三次握手与四次挥手。 流量控制：在回复ACK时，接收端介绍自己接受数据的缓冲区剩余大小。 拥塞控制：慢开始、拥塞避免等操作。 11. TCP快速重传的实现 举例：发送方发出1、2、3、4、5五份数据，1送到了，则回复ACK2，但是2没送到，3送到了，于是继续回复ACK2，后面4和5都送到了，继续回复ACK2，直到发送端收到三次ACK2，则重新发送2，然后接收端收到2，因为3、4、5都已经收到，所以回复ACK6。","link":"/2020/04/15/2020-04-15-%E7%BE%8E%E5%9B%A2%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86-1/"},{"title":"美团面经整理-2","text":"面经来源：美团后端实习一面 1. 两个有序链表合并成一个(leetcode 21) 12345678910111213141516171819202122struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {}};ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1 == NULL){ return l2; } if (l2 == NULL){ return l1; } if (l1-&gt;val &lt; l2-&gt;val){ l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } else { l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; }} 2. GET和POST的区别 GET所发送的数据是URL的一部分，POST数据不会显示在URL中。 GET和POST方法没有本质区别，只是报文格式不同，两者都使用HTTP，都是不安全的，想要安全传输需要使用HTTPS。 3. HTTPS的实现原理 HTTPS原理：在传输层（TCP）和应用层（HTTP）之间加了一层SSL/TLS。 具体加密过程：1. 服务器端发送公钥证书；2. 客户端检验证书是否有效，是，则生成一个随机密钥，并用服务端的公钥进行加密后发送；3. 服务器端用自己私钥加密，取出客户端的随机密钥，将需要发送的内容用该密钥加密并发送。 4. Linux查看最近的日志用什么指令 tail： tail -f test.log head： cat test.log | tail -n +3000 | head -n 1000 cat： cat filename tac：把cat的内容反写过来 tac filename echo： echo “the echo command test!” 5. hash冲突解决 开放地址法：再散列函数： Hi = (H(key) + di) % m, i = 1, 2, …, n 不同di值对应不同散列方法。 再哈希法：同时构造多个不同的哈希函数，某一个发生冲突时计算下一个，直到冲突不再产生。 链地址法：将所有哈希地址为i的元素构成一个单链表。 建立公共溢出区：将哈希表分为基本表和溢出表，和基本表发生冲突的元素填入溢出表。 6. 快排的时间复杂度和空间复杂度 平均情况下快速排序的时间复杂度是O(nlgn)，最坏情况是n的平方，可通过随机算法避免最坏情况，或者可先求序列的中值，然后选取中值作为主元素。 由于递归调用，快排的空间复杂度是O(lgn)。 7. 堆排序的时间复杂度和空间复杂度 第一次建堆时间复杂度：O(n)。 更改元素时建堆时间复杂度：O(nlgn)。 堆排序平均时间复杂度：O(nlgn)。 空间复杂度：O(1)。 8. B树和B+树的定义 B树中每个节点的关键字都有data域。 B+树除了叶子节点，其他节点只有索引。 9. C++ vector里size和capacity的区别 size是当前vector容器的真实占用大小。 capacity是当前允许的最大元素数。","link":"/2020/04/16/2020-04-16-%E7%BE%8E%E5%9B%A2%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86-2/"}],"tags":[{"name":"美团","slug":"美团","link":"/tags/%E7%BE%8E%E5%9B%A2/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"}],"categories":[{"name":"面经","slug":"面经","link":"/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"}]}