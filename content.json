{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/04/14/hello-world/"},{"title":"KMP Algorithm","text":"Background…Once upon a time, Tom asked his father to find abab inside abcaabababaa. Tom’s dad did this in a traditional way (brute force). He compared each character of the first string with each character of the second string. When he find one character not matching, for example, the third character in the second string in this case, he start again from the second character of the second string. It went on and on and on… Moving on…Unfortunately, Tom had a bad temper about waiting. He wanted to make some change. Tom noticed that, if the n-th character in the first string happened to be not match, even if he start again, he will make a compare with that character again in the future. Therefore, Tom decided not to start from the begining each time a not match is found. He talked to his dad, “when we have a not match for the n-th character, if we consider the characters before, we do have a big match, and if so, we actually can use the head of abab to try to match the tail of abab, the longest mathing substring will be the place for us to start again.” For example, for abab, there will be 3 possible heads: a, ab, aba. And there will be 3 possible tails: b, ab, bab. The longest matching is ab, so each time there’s a not mathing, we don’t need to start from begin, instead we can start from the 3-rd character to make a comparison. Coding work…Taking the above thought into real code, c++, for example: We first need a function to generate all the longest matching for each substring of the string we are trying to search. 1234567891011121314151617int * FindLongestMatching(string first){ int * tableOfFirst = new int[first.length()]; tableOfFirst[0] = -1; int i = 0; int j = -1; while (i &lt; p.length() - 1) { if (j == -1 || first[i] == first[j]) { i++； j++； tableOfFirst[i] = j; } else { j = tableOfFirst[j]; } } return tableOfFirst;} With this function, we can make a linear time matching: 123456789101112131415161718int KMP (string first, string second) { int i = 0; int j = 0; int * tableOfFirst = FindLongestMatching(first); while (i &lt; second.length() &amp;&amp; j &lt; first.length()) { if (j == -1 || second[i] == first[j]) { i++; j++; } else { j = tableOfFirst[j]; } } if (j == first.length()){ return i-j; } return -1;} Tom is happy now.","link":"/2020/04/17/2020-04-17-KMP-Algorithm/"},{"title":"美团面经整理-1","text":"面经来源：美团后端实习一面面经 c++ 1. C++的内存管理分哪些区，分别有什么作用 C++的内存主要分为五大区：堆区、栈区、自由存储区、全局/静态存储区、常量存储区。 堆区：程序员分配释放，使用new分配内存块，使用delete归还内存空间。 栈区：编译器自动分配释放，用于存放局部变量、函数参数等。 自由存储区：程序员分配释放，使用malloc分配内存块，使用free归还内存空间。 全局区/静态区：全局变量和静态变量分配在同一块内存中。 常量存储区：存放不可修改的常量值。 2. C++源文本到可执行文件需要经历哪些阶段 预处理：将源代码和相关头文件处理成一个.i文件。 编译：将预处理的文件进行词法分析、语义分析，优化后产生相应的汇编代码。 汇编：将汇编语言代码翻译成目标机器码。 链接：把每个机器码文件按照要求连接起来，解决代码间的相互依赖问题。 3. 析构函数为什么必须是虚函数 为了保证整个派生类的对象完全被释放。 当析构函数不为虚函数时，在删除基类指针时，只会调用基类析构函数，而不调用派生类的析构函数，这样会导致基类指针指向的派生类对象析构不完全。 当析构函数为虚函数时，在删除基类指针时，会调用该指针指向派生类的析构函数，同时派生类的析构函数自动调用基类析构函数，保证对象被完全释放。 4. 虚函数和纯虚函数有什么区别 虚函数：在基类中存在定义，可以直接使用，也可以被派生类重写后使用。 纯虚函数：在基类中不存在定义，只有声明，必须在子类中定义后才能使用。 5. 虚函数的实现机制 编译器自动为存在虚函数的类生成一个虚函数表，当声明该类的对象时，放入一个隐式指针变量，指向虚函数表。 在调用方法时，系统根据不同对象的指针，寻找到对应的虚函数表，进而找到所需的函数地址进行调用。 6.野指针怎么出现的 指针变量未初始化。 指针释放后未置空。 返回指向栈内存的指针。 7. 类和结构体有什么区别 class中默认成员访问权限为private，而struct中为public。 class可以用于表示模板类型，sruct不行。 class是引用类型，struct是值类型。 class多用来存储数据量大、逻辑复杂的对象，struct多用来存储轻量级对象。 class多用于表现抽象和多级别的对象层次。 8. 什么情况会导致内存泄漏 程序循环new创建出来的对象没有及时delete掉。 delete掉一个void*类型的指针，导致没有调用到对象的析构函数。 new创建了一组对象，回收时未调用delete[]，而调用了delete，导致只有对象数组的第一个对象的析构函数得到执行并回收了内存。 9. 五种IO模型 阻塞IO：进程发起IO系统调用后，进程被阻塞，转到内核空间处理，处理完毕后返回进程。 非阻塞IO：进程发起IO系统调用后，如果内核缓冲区没有数据，返回给进程一个错误，而不会阻塞进程，如果缓冲区有数据，则将数据返回给进程。【发起IO后，内核便开始处理，一直有返回值，但是直到内核处理完才有数据。】 IO复用：多个进程的IO注册到一个复用器（select）上，select监听所有进来的IO。【同时负责很多水龙头，哪个水龙头要来水了，就打开哪一个。】 信号驱动IO：进程发起IO系统调用后，向内核注册信号处理函数，然后进程返回不阻塞，当内核数据就绪则通知进程发起IO调用读取数据。【首先用信号通知内核空间，等到数据就绪再发起IO。】 异步IO：进程发起IO系统调用后，进程返回不阻塞，等内核将IO处理完，通知进程数据结果。 10. TCP如何保证传输的可靠性 校验和：接收方和发送方均进行校验和的计算，并进行对比。 序列号：TCP传输时将每个字节的数据都进行编号。 确认应答：TCP传输过程中，每次接收方收到数据后，均对传输方进行确认应答（ACK）。 超时重传：发送方在发送完数据后进行等待，一段时间后没有收到ACK，则对刚才的数据进行重新发送。 连接管理：三次握手与四次挥手。 流量控制：在回复ACK时，接收端介绍自己接受数据的缓冲区剩余大小。 拥塞控制：慢开始、拥塞避免等操作。 11. TCP快速重传的实现 举例：发送方发出1、2、3、4、5五份数据，1送到了，则回复ACK2，但是2没送到，3送到了，于是继续回复ACK2，后面4和5都送到了，继续回复ACK2，直到发送端收到三次ACK2，则重新发送2，然后接收端收到2，因为3、4、5都已经收到，所以回复ACK6。","link":"/2020/04/15/2020-04-15-%E7%BE%8E%E5%9B%A2%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86-1/"},{"title":"美团面经整理-2","text":"面经来源：美团后端实习一面 1. 两个有序链表合并成一个(leetcode 21) 12345678910111213141516171819202122struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {}};ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1 == NULL){ return l2; } if (l2 == NULL){ return l1; } if (l1-&gt;val &lt; l2-&gt;val){ l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } else { l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; }} 2. GET和POST的区别 GET所发送的数据是URL的一部分，POST数据不会显示在URL中。 GET和POST方法没有本质区别，只是报文格式不同，两者都使用HTTP，都是不安全的，想要安全传输需要使用HTTPS。 3. HTTPS的实现原理 HTTPS原理：在传输层（TCP）和应用层（HTTP）之间加了一层SSL/TLS。 具体加密过程：1. 服务器端发送公钥证书；2. 客户端检验证书是否有效，是，则生成一个随机密钥，并用服务端的公钥进行加密后发送；3. 服务器端用自己私钥加密，取出客户端的随机密钥，将需要发送的内容用该密钥加密并发送。 4. Linux查看最近的日志用什么指令 tail： tail -f test.log head： cat test.log | tail -n +3000 | head -n 1000 cat： cat filename tac：把cat的内容反写过来 tac filename echo： echo “the echo command test!” 5. hash冲突解决 开放地址法：再散列函数： Hi = (H(key) + di) % m, i = 1, 2, …, n 不同di值对应不同散列方法。 再哈希法：同时构造多个不同的哈希函数，某一个发生冲突时计算下一个，直到冲突不再产生。 链地址法：将所有哈希地址为i的元素构成一个单链表。 建立公共溢出区：将哈希表分为基本表和溢出表，和基本表发生冲突的元素填入溢出表。 6. 快排的时间复杂度和空间复杂度 平均情况下快速排序的时间复杂度是O(nlgn)，最坏情况是n的平方，可通过随机算法避免最坏情况，或者可先求序列的中值，然后选取中值作为主元素。 由于递归调用，快排的空间复杂度是O(lgn)。 7. 堆排序的时间复杂度和空间复杂度 第一次建堆时间复杂度：O(n)。 更改元素时建堆时间复杂度：O(nlgn)。 堆排序平均时间复杂度：O(nlgn)。 空间复杂度：O(1)。 8. B树和B+树的定义 B树中每个节点的关键字都有data域。 B+树除了叶子节点，其他节点只有索引。 9. C++ vector里size和capacity的区别 size是当前vector容器的真实占用大小。 capacity是当前允许的最大元素数。","link":"/2020/04/16/2020-04-16-%E7%BE%8E%E5%9B%A2%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86-2/"},{"title":"字节面经整理-1","text":"面经来源：测试开发实习全面经 1. 计算机网络分层模型 7层 (osi国际标准组织定制)： 应用层：为程序提供网络服务。 表示层：数据格式化，加密、解密。 会话层：建立、维护、管理会话链接。 传输层：建立、维护、管理端到端链接。 网络层：IP寻址和路由选择。 数据链路层：控制网络层与物理层之间的通信。 物理层：比特流传输。 四层 (TCP/IP)： 应用层：ping、DNS、telnet 传输层：UDP、TCP 网络层：ICMP、IP 数据链路层：ARP、DataLink、RARP 2. HTTP请求包含哪几个部分 请求行： 请求方法：HTTP最常见的请求方法为GET和POST。 请求URL：请求对应的URL地址。 HTTP协议及版本：协议名称及版本号。 请求头： 包含多个属性，格式为“属性名：属性值”，服务器根据请求头来获取客户端的信息。 请求体： 将一个页面表单中的组件值通过param1=value &amp; param2=value2的键值对形式编码成一个格式化串，承载多个请求参数的数据。 3. TCP拥塞控制 主要为四个算法： 慢开始：在TCP链接刚建立时，一点一点地增大拥塞窗口cwnd，慢慢变为指数增长，试探网络的承受能力，直到cwnd大于等于ssthresh（slow start threshold）则进入拥塞避免。 拥塞避免：收到一个ACK，即每经过一个往返时间RTT，就把发送方的cwnd加1，使其按线性规律缓慢增长。 乘法减小【TCP Tahoe】：不论在慢开始阶段还是拥塞避免阶段，只要出现超时，即可能发生了阻塞，发生丢包，就把慢开始门限ssthresh的值减半，即设置为当前cwnd的一半，并开始执行慢开始算法。 快速重传【TCP Reno】：发生丢包时，把cwnd设置为当前的一半，ssthresh设置为缩小后的cwnd大小，进入快速恢复算法。 快速恢复【TCP Reno】：设置cwnd=cwnd+3MSS（因为收到3个重复的ACK，所以加三个MSS），重传DACKs指定的数据包，如果再收到DACKs，则cwnd增加1，若收到新的ACK，表明重传包成功，退出快速恢复，将cwnd设置为ssthresh，进入*拥塞避免**算法。 4. 死锁与死锁的处理 形成死锁的四个必要条件： 互斥：在某段时间内某资源只由一个进程占用。 持有并等待：某进程已经持有一个或多个资源，但是还需请求其他资源，而它请求的资源不能立即获得，需要等待。 不可抢占：进程已经获取的资源在使用过程中不能被其他进程抢占，只能在使用完后，由该进程自己释放。 环路等待：形成进程和请求资源之间的环路。 死锁的预防： 互斥：不易预防 占有并等待：方法一：不持有并等待，如果一个进程一次请求获取不了所有资源，那么它不可占用任何资源，即释放掉它已经占有的资源；方法二：持有不等待，保证资源充足，只要请求资源，就分配给资源。 不可抢占：如果一个进程所请求的资源被另一进程占有，使它可以抢占另一进程占有的资源。 环路等待：对资源进行排序，每个进程按照固定的顺序访问资源。 死锁的避免： 资源请求图算法：利用资源分配图，引入需求边表示进程可能在将来某个时候申请资源，只有申请边变为分配边而不会导致资源分配图形成环时，才允许申请。 银行家算法：当新进程进入系统，系统对其所需资源的最大数量进行统计，若超过当前资源综合，则该进程必须等待直到其他进程释放资源。 5. 什么是关系型数据库 关系型数据库建立在关系型数据模型的基础上，借助于集合、代数等数学概念和方法来处理数据的数据库。 6. KV存储 举例：Redis、MongoDB 不经常更新的、重要的数据一般使用关系数据库存储。 数据结构简单、有分布式数据存储的需求使用KV数据库。 7. 非递归前中后序遍历二叉树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566struct TreeNode { int val; TreeNode * left; TreeNode * right;};void PreOrder (TreeNode * root) { stack&lt;TreeNode *&gt;s; TreeNode * ptr = root; while (ptr != nullptr || !s.empty()) { if (ptr != nullptr) { cout &lt;&lt; ptr-&gt;val &lt;&lt; endl; s.push(ptr); ptr = ptr-&gt;left; } else { ptr = s.top(); s.pop(); ptr = ptr-&gt;right; } }}void InOrder (TreeNode * root) { stack&lt;TreeNode *&gt; s; TreeNode * ptr = root; while (ptr != nullptr || !s.empty()) { if (ptr != nullptr) { s.push(ptr); ptr = ptr-&gt;left; } else { ptr = s.top(); cout &lt;&lt; ptr-&gt;val &lt;&lt; endl; s.pop(); ptr = ptr-&gt;right; } }}void PostOrder (TreeNode * root) { stack&lt;TreeNode *&gt; s; TreeNode * ptr = root; TreeNode * TemNode = nullptr; while (ptr != nullptr || !s.empty()) { if (ptr != nullptr { s.push(ptr); ptr = ptr-&gt;left; } else { ptr = s.top(); if (ptr-&gt;right != nullptr &amp;&amp; ptr-&gt;right !- TemNode){ ptr = ptr-&gt;right; } else { cout &lt;&lt; ptr-&gt;val &lt;&lt; endl; s.pop(); TemNode = ptr; ptr = nullptr; } } }} 8. 如何实现一个栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class QueueStack {private: queue&lt;int&gt; first; queue&lt;int&gt; second; public: bool empty() { if (first.empty() &amp;&amp; second.empty()){ return true; } else { return false; } } int top() { if (first.empty()){ return second.front(); } else { return first.front(); } } void pop() { if (first.empty()) { second.pop(); } else { first.pop(); } } void push (int x){ if (frist.empty()){ first.push(x); while (!second.empty()) { first.push(second.front()); second.pop(); } } else { second.push(x); while(!first.empty()) { second.push(first.front()); first.pop(); } } }} 9. HTTP状态码 1xx：收到请求，需要请求者继续操作。 100：继续。 101：切换协议。 2xx：操作被成功接收并处理。 200：请求成功。 201：已创建。 202：已接受。 203：非授权信息。请求成功。 204：无内容。 205：重置内容。 206：部分内容。 3xx：重定向，需要进一步操作以完成请求。 300：多种选择。 301：永久移动。 302：临时移动。 303：查看其他地址。 304：未修改。 305：使用代理。 307：临时重定向。 4xx：客户端错误，请求包含语法错误或无法完成请求。 400：Bad Request。 401：Unauthorized。 403：服务器理解客户端的请求，但是拒绝执行。 404：无法根据请求找到资源。 405：客户端请求中的方法被禁止。 406：Not Acceptable。 407：Proxy Authentication Required。 408：Request Timeout。 409：服务器处理请求时发生了冲突。 410：客户端请求的资源已经不存在。 411：Length Required。 412：Precondition Failed。 413：Request Entity Too Large。 414：Request URI Too Large。 415：Unsupported Media Type。 416：客户端请求的范围无效。 417：Expectation Failed。 5xx：服务器错误，服务器在处理请求的过程中发生了错误。 500：服务器内部错误，无法完成请求。 501：服务器不支持请求的功能。 502：Bad Gateway。 503：Service Unavailable。 504：Gateway Timeout。 505：HTTP version not supported。","link":"/2020/04/17/2020-04-17-%E5%AD%97%E8%8A%82%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86-1/"},{"title":"字节面经整理-2","text":"面经来源：字节跳动 测试开发岗 一二三轮凉经 1. 黑盒测试和白盒测试 黑盒测试：即功能性测试 等价类划分：有效等价类即对于程序的规格来说是合理的、有意义的；无效等价类即对程序的规格来说是不合理的、每有意义的。 边界值分析：对各种边界情况设计测试用例。 因果图法：根据输入的各种组合来设计测试用例，用于检查程序输入条件的各种组合情况。 场景法：通过对正常场景和中断操作的场景进行实验来完成测试。 白盒测试：即结构测试或逻辑驱动测试 静态测试：代码检查、结构分析、文档测试等。 动态测试：功能确认、接口测试、性能分析等。 2. 单元测试、集成测试和系统 单元测试：对函数、类的某一个方法等基本单元进行正确性检验的测试。 集成测试：对组装好的模块进行功能性验证的测试。 系统测试：对继承好的软件作为计算机系统的一部分与外围设备或支持性软件一起进行的实际测试。 3. 如何设计测试用例 利用1.中方法进行分析设计，需要包含用例编号、用例标题、功能模块名称、前置条件、输入数据、操作步骤、预期结果、优先级、执行结果、编写人、执行人、其他补充。 4. 如何测试微信的点赞功能 功能测试 点赞朋友圈，是否成功。 取消点赞，是否成功。 多次点赞，有何结果。 多人点赞，以何顺序呈现。 接口测试 被点赞人能否收到消息。 点赞人能否收到后续消息。 性能测试 点赞后，结果显示时间是否符合规范。 兼容测试 在安卓、ios上点赞，结构是否有差异。 可用性测试 网络连接不稳定时，点赞的结果。","link":"/2020/04/19/2020-04-19-%E5%AD%97%E8%8A%82%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86-2/"},{"title":"字节面经整理-3","text":"面经来源：字节跳动测试开发3面复盘 1. MySQL查询10-20条的数据 1select * from table limit 10, 20 2. 查找二叉树最大深度 1234567891011121314151617181920struct TreeNode { int val; TreeNode * left; TreeNode * right; TreeNode(int x) : val(x), left(NULL), right(NULL){}};int dfs (TreeNode * root, int result) { if (!root) { return result; } int left_res = dfs(root-&gt;left, result + 1); int right_res = dfs(root-&gt;right, result + 1); return max(left_res, right_res);}int MaxDepth(TreeNode * root) { int result = 0; return dfs(root, result);} 3. 判断IP地址是否合法 12345using namespace boost::xpressive; bool CheckIP(char *ip) { cregex expression = cregex::compile(\"(25[0-4]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])[.](25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])[.](25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])[.](25[0-4]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])\"); return regex_match(ip, expression); } 4. udp如何实现可靠连接 在应用层参照TCP实现超时重传、有序接受、应答确认、滑动窗口、流量控制等功能。 现已实现的程序有RUDP、RTP、UDT。 5.MySQL 查询以135开头的手机号 1select * from test where shouji like '135%';","link":"/2020/04/20/2020-04-19-%E5%AD%97%E8%8A%82%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86-3/"},{"title":"Sorting Algorithms - Summary","text":"In this series of blogs, we will talk about different sorting algorithms. All the algorithms in the table below will be covered. Algorithm Time Complexity (Average Case) Time Complexity (Worst Case) Time Complexity (Best Case) Merg Stability Bubble Sort O(N^2) O(N^2) O(N^2) O(1) Stable Quick Sort O(NlogN) O(N^2) O(NlogN) O(logN) Not Stable Quick Sort (with Random Selection) O(NlogN) O(NlogN) O(NlogN) O(logN) Not Stable Insertion Sort O(N^2) O(N^2) O(N) O(1) Stable Selection Sort O(N^2) O(N^2) O(N^2) O(1) Not Stable Heap Sort O(NlogN) O(NlogN) O(NlogN) O(1) Not Stable Merge Sort (with double divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Merge Sort (with multi divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Counting Sort O(N+M) O(N+M) O(N+M) O(N+M) Stable Bucket Sort O(N+M) O(N^2) O(N+M) O(N+M) Stable Radix Sort O(N*M) O(N*M) O(N*M) O(N+M) Stable","link":"/2020/04/21/2020-04-21-Sorting-Algorithms---Summary/"},{"title":"Sorting Algorithms - Bubble Sort","text":"In this series of blogs, we will talk about different sorting algorithms. All the algorithms in the table below will be covered. Algorithm Time Complexity (Average Case) Time Complexity (Worst Case) Time Complexity (Best Case) Merg Stability Bubble Sort O(N^2) O(N^2) O(N^2) O(1) Stable Quick Sort O(NlogN) O(N^2) O(NlogN) O(logN) Not Stable Quick Sort (with Random Selection) O(NlogN) O(NlogN) O(NlogN) O(logN) Not Stable Insertion Sort O(N^2) O(N^2) O(N) O(1) Stable Selection Sort O(N^2) O(N^2) O(N^2) O(1) Not Stable Heap Sort O(NlogN) O(NlogN) O(NlogN) O(1) Not Stable Merge Sort (with double divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Merge Sort (with multi divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Counting Sort O(N+M) O(N+M) O(N+M) O(N+M) Stable Bucket Sort O(N+M) O(N^2) O(N+M) O(N+M) Stable Radix Sort O(N*M) O(N*M) O(N*M) O(N+M) Stable Bubble SortHow to do it…Compare the adjacent elements. If the first element is greater than the second element, swap them. Loop until reaching the last pair of elements. Repeat until all the array is sorted. How to code it…123456789void BubbleSort(int array[]) { for (int i = 0; i &lt; array.length(); i++) { for (int j = 0; i &lt; array.length() - i; j++) { if (array[j] &gt; array[j+1]) { swap(array[j], array[j+1]); } } }} How to improve it…We can make a judgement before we do the algorithm. Check whether the array is already sorted or not. 1234567891011121314void BubbleSortwithCheck(int array[]) { for (int i = 0; i &lt; array.length(); i++) { bool sorted = true; for (int j = 0; j &lt; length() - i; j++) { if (array[j] &gt; array[j+1]) { swap(array[j], array[j+1]); sorted = false; } } if (sorted) { break; } }}","link":"/2020/04/22/2020-04-22-Sorting-Algorithms---Bubble-Sort/"},{"title":"Sorting Algorithms - Quick Sort","text":"In this series of blogs, we will talk about different sorting algorithms. All the algorithms in the table below will be covered. Algorithm Time Complexity (Average Case) Time Complexity (Worst Case) Time Complexity (Best Case) Merg Stability Bubble Sort O(N^2) O(N^2) O(N^2) O(1) Stable Quick Sort O(NlogN) O(N^2) O(NlogN) O(logN) Not Stable Quick Sort (with Random Selection) O(NlogN) O(NlogN) O(NlogN) O(logN) Not Stable Insertion Sort O(N^2) O(N^2) O(N) O(1) Stable Selection Sort O(N^2) O(N^2) O(N^2) O(1) Not Stable Heap Sort O(NlogN) O(NlogN) O(NlogN) O(1) Not Stable Merge Sort (with double divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Merge Sort (with multi divides) O(NlogN) O(NlogN) O(NlogN) O(N) Stable Counting Sort O(N+M) O(N+M) O(N+M) O(N+M) Stable Bucket Sort O(N+M) O(N^2) O(N+M) O(N+M) Stable Radix Sort O(N*M) O(N*M) O(N*M) O(N+M) Stable Quick SortHow to do it…Divide and conquer. In each division, seperate the data into two parts. All elements in the first part should be all less than the elements in the second part. Loop until the array is sorted. How to code it…12345678910111213141516171819202122int partition(int array[], int left, int right) { int pivot; if (left &lt; right) { int low = left; int high = right; int key = array[left]; while (low &lt; high) { while (array[high] &gt;= ket &amp;&amp; low &lt; high) { high--; } array[low] = array[high]; while (array[low] &lt;= array[high] &amp;&amp; low &lt; high) { low++; } array[high] = array[low]; } pivot = low; array[pivot] = key; } return pivot;} 1234567void QuickSort(int array[], int left, int right) { if (left &lt; right) { int pivot = partition(array, left, right); QuickSort(array, left, pivot - 1); QuickSort(array, pivot + 1, right); }} How to improve it…12345678910void QuickSortRandom(int array[], int left, int right) { if (left &lt; right) { srand(unsigned(time(NULL))); int Tem = rand()%(right - left + 1) + left; swap(array[left], array[Tem]); int pivot = partition(array, left, right); QuickSortRandom(array, left, pivot - 1); QuickSortRandom(array, pivot + 1, right); }}","link":"/2020/04/23/2020-04-23-Sorting-Algorithms---Quick-Sort/"},{"title":"Insurance Management System - Overview","text":"In this series of blogs, we will talk about how to build a Insurance Management web application together with database system. BackgroundTom’s dad works in an insurance company. His work is to drop down who bought what kind of insurance, on which day does the customer receives an invoice, and on which day does the customer makes a payment. Oneday, Tom’s dad talks to Tom: “Oh Tom, you see see you, one day day, only eat, do nothing, build a management system for me.” Tom becomes not happy. Rlational ModelTom’s dad talks to Tom about what information is needed. After discussion, Tom draws the following relational model: Summary of development environmentTom thinks it over and over, finally decides to apply the following development environment: Programming language: Python3.5 Framework: Django2.1.1 Database: SQLite Code editor: Pycharm Application FeaturesTo build the application, Tom mainly used the ORM model characteristic provided by Django. With ORM, so that he can treat each table as a CLASS in python and each time he insert data into that table, he simply instantiate an object, together with Object-Oriented Programming, he can make queries, add items, change information and delete object in a convenient way. The features of the application are but not restricted to: Normal UsersFor users who are new to the application, he/she can register themselves in the REGISTER page. As shown below, the REGISTER page can be access by clicking the REGISTER button on the right of system bar. If information is filled not properly, application will generate warnings to helper users. When information filled in the correct way, user will be directed to the login page with notice of successful account creation. After logging in, application will go to welcome page, where the username of user is confirmed again to make sure the user is about to purchase insurance. As long as the user has been logged in, the username and email will always be displayed on each page. After confirmation, the user will be guided to the insurance purchase page, the first insurance is Home insurance, after which user is required to enter the information about home under insurance. When Home insurance purchase is finished, user is going to the Auto insurance purchase page, after which the information about vehicle under insurance needs to be provided, and finally the driver information is also needed. Notice the side bar, there are more detailed instruction about how to buy different kinds of insurance. If the user want to check detailed information about the insurances purchased, he/she can click on the PROFILE button. In the PROFILE window, user can update email address if needed. And for each insurance listed, to check the detail information, just click on the insurance number will work. When finish browsing, user can click on LOGOUT to logout the account. Super UserFor users with administration power, they can go to 127.0.0.1:8000/admin/ to access the administrative page. After logging in, Tom can manage all stored data, including add invoice and payment information for different users. (Notice that users pay their bill in other sites, this site is just designed for users to choose insurance and look for records.) Project OutcomeIn this project, Tom designed and built a web-based database application. There are three fields Tom have outcomes: web development database development connection between web development and database development For the web development, Tom chose to use python as programming language and django as web framework. This combination guaranteed us a good view of Object Oriented Programming experience. All the users and each recorded were created as an object from CLASS Tom defined. Django is a MVT like frame, therefore, during web development, it is important to get clear of which page Tom are working on, which html Tom want to return and which template is required by django. For database, Tom used the simple but powerful SQLite to perform its duty. Together with Pycharm, Tom can clearly see the structure of our project and database, in addition to manage through admin page, Tom can also open the SQLite database with Navicat or other database management software to easily manage our SQL. The connection between database and web application is established by the ORM character of django, Tom can use OOP procedure to create and manage different records. But Tom also need to be clear about the foreign key relationship between different tables, each time Tom create or delete a record, Tom need to guarantee its foreign key (if any) is assigned. This gives us a good taste of how database is used in reality. Tom is happy now.","link":"/2020/04/28/2020-04-28-Insurance-Management-System---Overview/"}],"tags":[{"name":"美团","slug":"美团","link":"/tags/%E7%BE%8E%E5%9B%A2/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"字节","slug":"字节","link":"/tags/%E5%AD%97%E8%8A%82/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"Database","slug":"Database","link":"/tags/Database/"}],"categories":[{"name":"面经","slug":"面经","link":"/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Web","slug":"Web","link":"/categories/Web/"}]}